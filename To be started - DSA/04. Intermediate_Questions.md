
## ğŸ§® **Question 1: Find the Longest Substring Without Repeating Characters**

**Problem Statement:**
Given a string `s`, find the length of the **longest substring** that contains no repeating characters.

**Example:**

```
Input: "abcabcbb"
Output: 3   (The answer is "abc")
```

**Follow-up:**

* Solve in **O(n)** time.
* Discuss how youâ€™d handle **streaming input** if the string arrives as a data stream.

---

### ğŸ¯ Key Concept:

This problem introduces one of the most important DSA patterns:

> **The Sliding Window Technique** (used heavily in string, array, and stream processing problems).

---

1. Describe your **approach** â€” how youâ€™d detect and maintain a substring without duplicates.
2. Mention the **data structures** youâ€™d use.
3. If you feel confident, write a **simple code outline** or pseudocode.
4. Then Iâ€™ll give you the **complete interview-style breakdown**:

   * Brute force â†’ Optimal (Sliding Window)
   * Step-by-step **window movement diagram**
   * Interview explanation + streaming insight



   # Solution â€” Longest Substring Without Repeating Characters

(From brute force â†’ optimal, with interview script + visual step-by-step for `"abcabcbb"` and streaming handling)

---

## 1) Problem restatement (how to say it in an interview)

> â€œGiven a string `s`, find the length of the longest substring that contains **no repeated characters**.
> For example `s = "abcabcbb"` â†’ the answer is `3` because `"abc"` is the longest substring without repeats.â€

---

## 2) Brute-force approaches (explain first in interview)

### A. Straight brute force (explicit substrings)

* Generate **all** substrings (two loops) and check each substring for duplicates (a set).
* Checking duplicates takes up to O(n), generating substrings is O(nÂ²) â†’ overall **O(nÂ³)** worst-case.

```text
Pseudo:
for i in 0..n-1:
  for j in i..n-1:
    if substring s[i..j] has all unique chars:
      update max
```

**Time:** O(nÂ³)
**Space:** O(min(n,alphabet)) for the uniqueness check.

### B. Improved brute force (stop early using a set)

* For each `i`, extend `j` while characters are unique (use a set). This removes the inner linear check and becomes O(nÂ²) time in worst case.

**Time:** O(nÂ²)
**Space:** O(k) where k = unique chars in current window.

> **Interview tip:** Mention both; say brute-force is fine to start, but you optimize to O(n) using sliding window.

---

## 3) Optimal approach â€” Sliding Window with last-seen index (O(n))

**Idea (interview-friendly):**
Use two pointers `left` and `right` to maintain a **window [left, right]** with unique characters. Use a dictionary `last_index` that stores the most recent index of each character. When we see a repeated character `ch` at `right`, move `left` to `last_index[ch] + 1` if that last index is inside the current window. Update `last_index[ch] = right`. Track `max_len` as `right - left + 1`.

**Why O(n):** each character is visited once by `right`, and `left` only moves forward.

### Python implementation (clear & interview-ready)

```python
def length_of_longest_substring(s: str) -> int:
    last_index = {}      # char -> last seen index
    left = 0             # window start
    max_len = 0

    for right, ch in enumerate(s):
        if ch in last_index and last_index[ch] >= left:
            # repeated char inside current window -> move left
            left = last_index[ch] + 1
        # update last seen index of ch
        last_index[ch] = right
        # update max length
        max_len = max(max_len, right - left + 1)

    return max_len

# Example
print(length_of_longest_substring("abcabcbb"))  # prints 3
```
Another Method/Approach of Code:

```python
def solve(str: str) -> int:
    if len(str) == 0:
        return 0
    maxans = float("-inf")
    setx = set()
    l = 0
    for r in range(len(str)):  # outer loop for traversing the string
        if str[r] in setx:  # if duplicate element is found
            while l < r and str[r] in setx:
                setx.remove(str[l])
                l += 1
        setx.add(str[r])
        maxans = max(maxans, r - l + 1)
    return maxans
```


**Complexities:**

* **Time:** O(n)
* **Space:** O(k) where k is number of distinct characters (â‰¤ alphabet size)

---

## 4) Step-by-step window changes for `"abcabcbb"` (detailed table + ASCII diagram)

String indices: `0 1 2 3 4 5 6 7`
String:         `a b c a b c b b`

Start: `left = 0`, `max_len = 0`, `last_index = {}`

| right | ch | last_index before | left (updated) | window indices [left..right] | window substring | max_len |
| ----- | -- | ----------------: | -------------: | ---------------------------: | ---------------: | ------: |
| 0     | a  |                {} |              0 |                       [0..0] |              "a" |       1 |
| 1     | b  |             {a:0} |              0 |                       [0..1] |             "ab" |       2 |
| 2     | c  |         {a:0,b:1} |              0 |                       [0..2] |            "abc" |       3 |
| 3     | a  |     {a:0,b:1,c:2} |  max(0,0+1) =1 |                       [1..3] |            "bca" |       3 |
| 4     | b  |     {a:3,b:1,c:2} |  max(1,1+1) =2 |                       [2..4] |            "cab" |       3 |
| 5     | c  |     {a:3,b:4,c:2} |  max(2,2+1) =3 |                       [3..5] |            "abc" |       3 |
| 6     | b  |     {a:3,b:4,c:5} |  max(3,4+1) =5 |                       [5..6] |             "cb" |       3 |
| 7     | b  |     {a:3,b:6,c:5} |  max(5,6+1) =7 |                       [7..7] |              "b" |       3 |

**Final `max_len = 3`.**

### ASCII Diagram (window shown as `[...]`)

```
Iteration r=0 ('a'):  window [0..0] = [a]       max=1
Iteration r=1 ('b'):  window [0..1] = [a b]     max=2
Iteration r=2 ('c'):  window [0..2] = [a b c]   max=3
Iteration r=3 ('a'):  repeated 'a' -> move left to 1
                     window [1..3] = [b c a]   max=3
Iteration r=4 ('b'):  repeated 'b' -> move left to 2
                     window [2..4] = [c a b]   max=3
Iteration r=5 ('c'):  repeated 'c' -> move left to 3
                     window [3..5] = [a b c]   max=3
Iteration r=6 ('b'):  repeated 'b' -> move left to 5
                     window [5..6] = [c b]     max=3
Iteration r=7 ('b'):  repeated 'b' -> move left to 7
                     window [7..7] = [b]       max=3
```

---

## 5) Streaming input handling (how to do this if characters arrive one-by-one)

If the string is a stream (characters come sequentially and you must maintain the longest unique-substring seen so far), you can keep the same state across incoming characters:

State to maintain between arrivals:

* `left` (window start)
* `last_index` map
* `max_len` (best seen so far)

Each incoming char `ch` at stream index `i`:

1. If `ch` was last seen at index `j >= left`, set `left = j + 1`.
2. Update `last_index[ch] = i`.
3. Update `max_len = max(max_len, i - left + 1)`.
4. Optionally emit `max_len` (current best) or current window substring.

### Streaming example code (process char-by-char)

```python
class LongestUniqueSubstringStream:
    def __init__(self):
        self.last_index = {}
        self.left = 0
        self.max_len = 0
        self.current_index = -1

    def process_char(self, ch):
        self.current_index += 1
        i = self.current_index
        if ch in self.last_index and self.last_index[ch] >= self.left:
            self.left = self.last_index[ch] + 1
        self.last_index[ch] = i
        self.max_len = max(self.max_len, i - self.left + 1)
        return self.max_len

# simulate stream
stream_processor = LongestUniqueSubstringStream()
for ch in "abcabcbb":
    print(ch, "->", stream_processor.process_char(ch))
# outputs 1,2,3,3,3,3,3,3  (max_len seen so far after each char)
```

**Notes:**

* You donâ€™t need the whole string stored. You keep only the `last_index` map and the integer counters.
* If the stream is extremely long / unbounded and the alphabet is small (e.g., ASCII), memory is bounded by the alphabet size. If the alphabet is huge, consider eviction policies or compression.

---

## 6) What to say in the interview (concise script)

1. **Restate problem** briefly to confirm understanding.

   > â€œWe want the length of the longest substring with unique characters.â€

2. **Describe simple solution** (brute force) to show you can reason from basics.

   > â€œBrute force checks all substrings â€” O(nÂ³) naive, can be improved to O(nÂ²) by using a set per start index.â€

3. **Introduce the sliding window** and why it helps:

   > â€œUse two pointers to maintain a window of unique chars and a hash map of last-seen indices to jump the left pointerâ€”this makes it O(n).â€

4. **Explain key invariant**:

   > â€œAt any time, indices `[left..right]` are unique characters. When a repeat appears, left jumps to `last_index[ch] + 1` (if inside window).â€

5. **State complexity**: O(n) time, O(k) space.

6. **Edge cases**: empty string -> 0; all same chars -> 1; unicode chars -> same method works.

7. **If asked about streaming**: describe the maintained state (`left`, `last_index`, `max_len`) and how you can process each incoming char in O(1) amortized.

---

## 7) Variations & follow-ups worth mentioning

* Return the actual substring (store start index of best window).
* Allow `k` distinct chars (generalized sliding-window, e.g., â€œlongest substring with at most k distinct charsâ€).
* Explain relation to real systems: windowed deduplication in streaming engines and maintaining per-key state in Flink/Spark streaming.





The **Sliding Window** technique forms the backbone of many string and array problems, especially those related to **substrings, subarrays, and frequency tracking**.

So here are **3 practice variations** of increasing difficulty based on the **Longest Substring Without Repeating Characters** pattern:

---

## ğŸ§© **Variation 1 (Easyâ€“Intermediate): Longest Substring with At Most K Distinct Characters**

### ğŸ§  Problem:

Given a string `s` and an integer `k`, find the **length of the longest substring** that contains **at most `k` distinct characters**.

**Example:**

```
Input: s = "eceba", k = 2
Output: 3
Explanation: "ece" has 2 distinct characters and is the longest.
```

**Pattern used:**
Sliding window with **hash map** to count character frequency.

**Interview tip:**
Emphasize how you **shrink the window** when the number of distinct characters exceeds `k`.

---

## ğŸ§© **Variation 2 (Intermediate): Longest Subarray with Sum â‰¤ K**

### ğŸ§  Problem:

Given an array of positive integers and an integer `k`, find the **length of the longest subarray** with a **sum less than or equal to `k`**.

**Example:**

```
Input: arr = [1, 2, 1, 0, 1, 1, 0], k = 4  
Output: 5  
Explanation: [1,2,1,0] or [2,1,0,1] â†’ both have sum â‰¤ 4
```

**Pattern used:**
Sliding window with **running sum**; expand window when sum â‰¤ k, contract when sum > k.

**Interview tip:**
This introduces the **numerical version** of the sliding window â€” commonly used in **data stream aggregation or rate-limiting systems**.

---

## ğŸ§© **Variation 3 (Advanced): Minimum Window Substring**

### ğŸ§  Problem:

Given two strings `s` and `t`, find the **minimum window** in `s` that contains all characters of `t`.

**Example:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
```

**Pattern used:**
Sliding window with **two hash maps** â€” one for target frequencies, one for current window.

**Interview tip:**
This is a **classic advanced problem** â€” most senior-level interviews include it.
Here, you maintain a dynamic count of required vs. current characters and track the smallest valid window.

---

## ğŸ” Summary Table

| Level     | Problem                                         | Key Idea               | Extra Concept                     |
| --------- | ----------------------------------------------- | ---------------------- | --------------------------------- |
| ğŸŸ¢ Easy   | Longest substring with at most K distinct chars | Window + HashMap       | Shrinking based on distinct count |
| ğŸŸ¡ Medium | Longest subarray with sum â‰¤ K                   | Window + Prefix Sum    | Sliding sum maintenance           |
| ğŸ”´ Hard   | Minimum window substring                        | Dual HashMaps + Window | Character frequency matching      |

