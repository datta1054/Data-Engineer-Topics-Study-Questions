

## Jump to

You can quickly jump to any question below:

- [Question 1 ‚Äî First Non-Repeating Character in a Stream](#q1)
- [Question 2 ‚Äî Move Zeroes to End](#q2)
- [Question 3 ‚Äî Element with Maximum Frequency](#q3)

---

<a id="q1"></a>

### üßÆ **Question 1: Find the First Non-Repeating Character in a Stream**

You are given a string (or character stream).
Return the **first non-repeating character**. If all characters repeat, return `None`.

**Example:**

```
Input: "swiss"  
Output: 'w'
```

**Follow-up:**

* Solve it in O(n) time.
* Discuss how you would handle this if the input is a **stream of data** instead of a fixed string.

---

Go ahead and tell me:

1. Your **approach** (or code if you prefer).
2. The **time & space complexity** you think your solution has.



## **Problem:** First Non-Repeating Character in a Stream

### **Step 1: Approach (Interview-friendly explanation)**

> ‚ÄúI want to find the first character in the string (or stream) that appears only once.
> To do this efficiently, I can use a **hash map** to track the frequency of each character, and a **queue** to keep track of the order in which characters appear.
> As I process each character, I update the frequency and check the front of the queue ‚Äî if the character at the front repeats, I remove it. The first character left in the queue is my first non-repeating character.‚Äù

**Why this works:**

* Hash map ‚Üí tracks counts (O(1) access).
* Queue ‚Üí keeps order of arrival, so we can always peek the first non-repeating character.

**Time Complexity:** O(n) ‚Üí each character is processed at most twice (once in queue, once removed).
**Space Complexity:** O(k) ‚Üí k is the number of unique characters.

---

### **Step 2: Implementation (Python)**

```python
from collections import deque, defaultdict

def first_non_repeating(stream):
    freq = defaultdict(int)  # frequency map
    q = deque()              # queue for order of characters

    for ch in stream:
        freq[ch] += 1        # update frequency
        q.append(ch)         # add to queue

        # Remove all repeating characters from the front of the queue
        while q and freq[q[0]] > 1:
            q.popleft()
        
        # Front of queue is first non-repeating character
        if q:
            print(f"First non-repeating so far: {q[0]}")
        else:
            print("First non-repeating so far: None")
    
    return q[0] if q else None

# Test
print("First non-repeating character:", first_non_repeating("swiss"))
```

---

### **Step 3: How the Queue Changes for `"swiss"`**

We process **each character step by step**:

| Character | Queue State | Frequency Map   | First Non-Repeating |
| --------- | ----------- | --------------- | ------------------- |
| `s`       | s           | {s:1}           | s                   |
| `w`       | s, w        | {s:1, w:1}      | s                   |
| `i`       | s, w, i     | {s:1, w:1, i:1} | s                   |
| `s`       | w, i        | {s:2, w:1, i:1} | w                   |
| `s`       | w, i        | {s:3, w:1, i:1} | w                   |

‚úÖ **Output:** `'w'`

**Visualization Diagram:**

```
Step 1: s          -> Queue: [s]  
Step 2: w          -> Queue: [s, w]  
Step 3: i          -> Queue: [s, w, i]  
Step 4: s repeats  -> Queue: [w, i]  
Step 5: s repeats  -> Queue: [w, i]  
First Non-Repeating Character: w
```

---

### **Step 4: How to Explain in an Interview**

> 1. Start by explaining the problem in your own words.
> 2. Describe the **data structures** you will use (hash map + queue).
> 3. Explain **step by step how you process each character**.
> 4. Discuss **time & space complexity**.
> 5. If it‚Äôs a stream, mention:
>
> * We don‚Äôt need to know the length in advance.
> * We keep updating frequency map & queue dynamically.





<a id="q2"></a>

### üßÆ **Question 2: Move Zeroes to End**

**Problem:**
You are given an array of integers. Move all zeros to the end of the array **while maintaining the relative order of non-zero elements**. Do this **in-place**.

**Example:**

```
Input: [0, 1, 0, 3, 12]  
Output: [1, 3, 12, 0, 0]
```

**Constraints / Follow-up:**

* Do not use extra array (O(1) extra space).
* Minimize the number of operations.

---

Go ahead and give me:

1. Your **approach / steps**
2. **Code** if possible
3. **Time & space complexity**




## **Problem:** Move Zeroes to End

**Input:** `[0, 1, 0, 3, 12]`
**Output:** `[1, 3, 12, 0, 0]`

---

## **Step 1: Brute Force Approach**

**Idea:**

* Create a new array.
* First, copy all non-zero elements.
* Then, fill the remaining positions with zeros.

**Python Code (Brute Force):**

```python
def move_zeroes_bruteforce(arr):
    n = len(arr)
    result = []

    # Step 1: Add non-zero elements
    for num in arr:
        if num != 0:
            result.append(num)
    
    # Step 2: Add zeros
    zeros_count = n - len(result)
    result.extend([0] * zeros_count)
    
    return result

# Test
print(move_zeroes_bruteforce([0, 1, 0, 3, 12]))
```

**Time Complexity:** O(n) (traverse array twice)
**Space Complexity:** O(n) (extra array)

> **Interview Tip:** Start with this simple idea, then explain why it‚Äôs not optimal because it uses extra space.

---

## **Step 2: Optimal Approach (In-place, Two-Pointer)**

**Idea:**

* Use a **slow pointer (`last_non_zero`)** to track the position of the next non-zero element.
* Traverse the array with a **fast pointer (`i`)**:

  * If `arr[i] != 0`, swap it with `arr[last_non_zero]` and increment `last_non_zero`.

**Python Code (Optimal):**

```python
def move_zeroes_optimal(arr):
    last_non_zero = 0  # Position to place next non-zero

    for i in range(len(arr)):
        if arr[i] != 0:
            arr[i], arr[last_non_zero] = arr[last_non_zero], arr[i]
            last_non_zero += 1

    return arr

# Test
print(move_zeroes_optimal([0, 1, 0, 3, 12]))
```



```python
def move_zeroes_optimal(arr):
    last_non_zero = 0  # Position to place next non-zero

    for i in range(len(arr)):
        if arr[i] != 0:
            arr[last_non_zero] = arr[i]
            last_non_zero+=1
    for i in range(last_non_zero, len(arr)):
        arr[i]=0
    return arr

# Test
print(move_zeroes_optimal([0, 1, 0, 3, 12]))
```

**Time Complexity:** O(n) ‚Äî traverse array once
**Space Complexity:** O(1) ‚Äî in-place

> **Interview Tip:** Always explain the **two-pointer approach**. It shows you can optimize space and operations.

---

## **Step 3: How the Array Changes Step by Step**

**Input:** `[0, 1, 0, 3, 12]`

| i (fast) | arr              | last_non_zero | Action                                               |
| -------- | ---------------- | ------------- | ---------------------------------------------------- |
| 0        | [0, 1, 0, 3, 12] | 0             | arr[0] is 0, skip                                    |
| 1        | [0, 1, 0, 3, 12] | 0             | Swap arr[1] & arr[0] ‚Üí [1,0,0,3,12], last_non_zero=1 |
| 2        | [1, 0, 0, 3, 12] | 1             | arr[2] is 0, skip                                    |
| 3        | [1, 0, 0, 3, 12] | 1             | Swap arr[3] & arr[1] ‚Üí [1,3,0,0,12], last_non_zero=2 |
| 4        | [1, 3, 0, 0, 12] | 2             | Swap arr[4] & arr[2] ‚Üí [1,3,12,0,0], last_non_zero=3 |

‚úÖ **Final Output:** `[1, 3, 12, 0, 0]`

---

### **Step 4: Visualization Diagram**

```
Initial: [0, 1, 0, 3, 12]  last_non_zero=0

Step1: Swap 1 and 0 -> [1, 0, 0, 3, 12]  last_non_zero=1
Step2: Skip 0 -> [1, 0, 0, 3, 12]         last_non_zero=1
Step3: Swap 3 and 0 -> [1, 3, 0, 0, 12]  last_non_zero=2
Step4: Swap 12 and 0 -> [1, 3, 12, 0, 0] last_non_zero=3
```

---

### **Step 5: How to Explain in an Interview**

1. **Start with brute force** ‚Üí shows you can solve it clearly first.
2. **Then explain drawbacks** (extra space).
3. **Move to optimal approach** ‚Üí two-pointer explanation.
4. **Explain step-by-step** using a small example (like above).
5. **Discuss complexities**.
6. Optional: Ask interviewer if they want **streaming input handling** ‚Äî good for data engineering context.



In a **streaming scenario**, the array isn‚Äôt available all at once ‚Äî elements arrive one by one. We want to maintain the invariant: **all non-zero elements are at the front, in order, and zeros at the end**.

---

## **Step 1: Data Structure Choice**

For streaming:

* Maintain a **list** for non-zero elements (or pointer index for in-place if mutable array is allowed).
* Count **zeros** seen so far.

As each element arrives:

1. If it‚Äôs non-zero ‚Üí append/move it to the next available non-zero position.
2. If it‚Äôs zero ‚Üí just increment the zero count.
3. At any moment, the first `len(non-zero elements)` positions contain all non-zero elements; remaining positions are zeros.

---

## **Step 2: Python Implementation (Streaming)**

```python
def move_zeroes_stream(stream):
    result = []       # non-zero elements
    zero_count = 0    # count of zeros

    for num in stream:
        if num != 0:
            result.append(num)
        else:
            zero_count += 1
        
        # Optional: print current state
        print(result + [0]*zero_count)

    # Final array
    return result + [0]*zero_count

# Simulating streaming input
stream_data = [0, 1, 0, 3, 12]
final_arr = move_zeroes_stream(stream_data)
print("Final array after stream:", final_arr)
```

**Output:**

```
[0]
[1, 0]
[1, 0, 0]
[1, 3, 0, 0]
[1, 3, 12, 0, 0]
Final array after stream: [1, 3, 12, 0, 0]
```

---

## **Step 3: Visualization (Streaming)**

```
Stream: 0 -> 1 -> 0 -> 3 -> 12

Step1: 0       -> [0]
Step2: 1       -> [1,0]
Step3: 0       -> [1,0,0]
Step4: 3       -> [1,3,0,0]
Step5: 12      -> [1,3,12,0,0]
```

* At each step, you can **emit the current array** if needed (useful in real-time dashboards).
* No need to know total length in advance ‚Üí perfect for streaming.

---

## **Step 4: Interview Explanation**

1. Mention the **streaming constraint**: cannot hold entire array at once.
2. Use **incremental approach**: maintain **non-zero elements + zero count**.
3. Show how you **update state with each incoming element**.
4. Discuss **time complexity O(n)** and **space O(n)** for storing non-zero elements (or O(1) if modifying an in-place buffer).
5. Optional: Mention **real-time systems**, e.g., Kafka stream or Spark Structured Streaming, where you maintain a similar state per partition.




<a id="q3"></a>

## üßÆ **Question 3: Find the Element with Maximum Frequency**

**Problem:**
Given an array of integers, find the element that appears **most frequently** (the mode).
If multiple elements have the same maximum frequency, return **any one of them**.

**Example:**

```
Input: [1, 3, 2, 1, 4, 1, 3, 3]
Output: 1 or 3  (both appear 3 times)
```

**Constraints:**

* Try to solve it in **O(n)** time.
* Space complexity should be **O(k)**, where *k* = number of unique elements.

---

Now your turn:

1. Tell me your **approach** (brute force and/or optimized).
2. Write **code** if you‚Äôd like.
3. Give your **time & space complexity**.

Then I‚Äôll walk you through:

* How to explain both versions in an interview
* The **visual frequency count diagram** to make it crystal clear.


Excellent üëè ‚Äî let‚Äôs go step-by-step, just like you‚Äôd do in an **actual interview setting**.
This question is a **classic hash map counting problem** ‚Äî super common and easy to expand into more complex data aggregation scenarios in **data engineering**.

---

## üß© **Question Recap:**

Find the element that appears most frequently in an array.

**Example:**

```
Input: [1, 3, 2, 1, 4, 1, 3, 3]
Output: 1 or 3  (both appear 3 times)
```

---

## üß† **Step 1: Brute Force Approach**

**Thought Process (How to explain in interview):**

> ‚ÄúLet‚Äôs start with a simple approach.
> For each element, I‚Äôll count how many times it appears in the array using a nested loop.
> I‚Äôll keep track of the element with the maximum count.‚Äù

**Python Code (Brute Force):**

```python
def most_frequent_bruteforce(arr):
    max_count = 0
    result = None

    for num in arr:
        count = 0
        for x in arr:
            if x == num:
                count += 1
        if count > max_count:
            max_count = count
            result = num
    
    return result
```

**Time Complexity:** O(n¬≤) ‚Üí two nested loops
**Space Complexity:** O(1)

**Why it‚Äôs not optimal:**

* For large data (like billions of records in data pipelines), O(n¬≤) is impractical.

> üîπ *In interview*: Acknowledge this first, then confidently transition to the optimal solution.

---

## ‚öôÔ∏è **Step 2: Optimal Approach (Using Hash Map / Dictionary)**

**Thought Process (Interview explanation):**

> ‚ÄúWe can optimize this using a hash map (dictionary in Python).
> As we iterate through the array once, we count the occurrences of each number.
> Then, we find the key with the maximum value in the map.‚Äù

**Python Code (Optimal Solution):**

```python
from collections import defaultdict

def most_frequent_optimal(arr):
    freq = defaultdict(int)
    max_count = 0
    result = None

    for num in arr:
        freq[num] += 1
        if freq[num] > max_count:
            max_count = freq[num]
            result = num
    
    return result
```

**Time Complexity:** O(n)
**Space Complexity:** O(k) ‚Üí k is number of unique elements

---

## üßæ **Step 3: How the Hash Map Changes Step by Step**

Let‚Äôs visualize for:

```
arr = [1, 3, 2, 1, 4, 1, 3, 3]
```

| Step | Element | Frequency Map (after step) | Current Max | Most Frequent |
| ---- | ------- | -------------------------- | ----------- | ------------- |
| 1    | 1       | {1:1}                      | 1           | 1             |
| 2    | 3       | {1:1, 3:1}                 | 1           | 1             |
| 3    | 2       | {1:1, 3:1, 2:1}            | 1           | 1             |
| 4    | 1       | {1:2, 3:1, 2:1}            | 2           | 1             |
| 5    | 4       | {1:2, 3:1, 2:1, 4:1}       | 2           | 1             |
| 6    | 1       | {1:3, 3:1, 2:1, 4:1}       | 3           | 1             |
| 7    | 3       | {1:3, 3:2, 2:1, 4:1}       | 3           | 1             |
| 8    | 3       | {1:3, 3:3, 2:1, 4:1}       | 3           | 1 or 3        |

‚úÖ **Final Output:** `1` or `3`

---

## üé® **Step 4: Visualization Diagram**

```
Array: [1, 3, 2, 1, 4, 1, 3, 3]

Freq Map Build Process:
Step1: 1 ‚Üí {1:1}
Step2: 3 ‚Üí {1:1, 3:1}
Step3: 2 ‚Üí {1:1, 3:1, 2:1}
Step4: 1 ‚Üí {1:2, 3:1, 2:1}
Step5: 4 ‚Üí {1:2, 3:1, 2:1, 4:1}
Step6: 1 ‚Üí {1:3, 3:1, 2:1, 4:1}
Step7: 3 ‚Üí {1:3, 3:2, 2:1, 4:1}
Step8: 3 ‚Üí {1:3, 3:3, 2:1, 4:1}

Most Frequent Element = 1 or 3
```

---

## üó£Ô∏è **Step 5: How to Explain in an Interview**

Here‚Äôs how your spoken flow might sound üëá

> ‚ÄúI started with a brute-force approach that uses nested loops, but that takes O(n¬≤) time.
> Since counting frequencies is a classic hash map problem, I optimized it using a dictionary where keys are numbers and values are counts.
> As I iterate through the array, I update the frequency and track the element with the highest count so far.
> This reduces the complexity to O(n), which is ideal for large-scale data.
>
> For visualization, I imagine building a frequency table as data streams in ‚Äî similar to aggregating counts in Spark or SQL‚Äôs `GROUP BY` operation.‚Äù

---

## ‚ö° **Bonus (Data Engineering Perspective)**

In a **streaming or batch context**, this problem maps directly to **‚Äúword count‚Äù or ‚Äúfrequency aggregation‚Äù**:

* In **Spark / Flink**, you‚Äôd use a `reduceByKey()` or `groupByKey()` operation.
* In **SQL**, it‚Äôs `SELECT value, COUNT(*) FROM table GROUP BY value ORDER BY COUNT(*) DESC LIMIT 1`.


