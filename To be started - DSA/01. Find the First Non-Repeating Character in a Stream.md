# Find the First Non-Repeating Character in a Stream

---

## 1. Problem Restatement

> **Given:** A stream of characters arriving one-by-one.
>
> **Task:** After each new character, output the first non-repeating character seen so far (or a sentinel like `-1` if none).
>
> **Constraint:** Must be an online solution (answer after each character).

**In short:** Maintain and report the first character with frequency 1 after each character is appended to the stream.

---

## 2. Input, Output, and Constraints

- **Input:**
  - A sequence/stream of characters (e.g., a string `s = "aabcbd"` or characters arriving one-by-one).
- **Output:**
  - After each character, return the current first non-repeating character (or `-1` / `None` / `#` — use one consistent sentinel).
  - Example output: `['a', '-1', 'b', 'b', ...]` (list of characters/sentinels for each prefix).
- **Constraints:**
  - Stream length $n$ can be large (up to $10^5$ or more) — prefer $O(n)$ time overall.
  - Alphabet size might be small (ASCII/lowercase) or large (Unicode). Fixed alphabet solutions can be more memory efficient.
  - **Must be online** — answer after each character.

---

## 3. Example Test Cases

| Input      | Output            | Explanation                                                                 |
|------------|-------------------|-----------------------------------------------------------------------------|
| `"aabc"`   | `['a', -1, 'b', 'b']` | After 'a' → 'a' is first non-repeating. After second 'a' → none (-1). After 'b' → 'b'. After 'c' → 'b' (still first non-repeating). |
| `"zz"`     | `['z', -1]`           |                                                                             |
| `"abadbc"` | `['a','b','b','d','d','c']` | Walkthrough: 'a'→a; 'b'→b (a repeated now); after 'ab' both unique but a arrived before b so a is still first unique; 'aba'→b (a repeated so first nonrepeat is b); 'abad'→b; 'abadb'→d (b repeated), 'abadbc'→d? |

---

## 4. Approach Breakdown

We present three levels:
- **Brute Force**
- **Improved / Better**
- **Optimal (Interview-Ready)**

### 4.1 Brute Force — $O(n^2)$ Time, $O(1)$ Extra Space

**Idea:**
- For every prefix of the stream (after each character), scan the entire prefix from left to right and find the first character whose frequency is exactly 1.
- Counting frequency in that prefix requires scanning again or maintaining a frequency array for the prefix and then scanning prefix — cost is quadratic in total.

**Pseudocode:**
```python
result = []
for i from 0 to n-1:
    prefix = stream[0..i]
    found = False
    for j from 0 to i:
        if count of prefix[j] in prefix == 1:
            result.append(prefix[j])
            found = True
            break
    if not found:
        result.append(-1)
return result
```

**Worked Example:**
- $s = "aba"$
  - $i=0$ → prefix 'a' → scan → 'a' unique → result[0] = 'a'
  - $i=1$ → prefix 'ab' → scan 'a' (still unique) → result[1] = 'a'
  - $i=2$ → prefix 'aba' → scan 'a' (freq 2) → next 'b' freq1 → result[2]='b'

**Complexity:**
- **Time:** $O(n^2)$ in worst case (sum of prefix scans).
- **Space:** $O(1)$ extra or $O(k)$ if you maintain frequency for alphabet size $k$. Output list uses $O(n)$.

> **Why this is weak:** Too slow for large streams.

---

### 4.2 Improved / Better — $O(n)$ Average Time, $O(k)$ Space

**Intuition:**
- Keep a global frequency map (character → count) updated as each character arrives.
- To find the first non-repeating, keep an ordered list/array of candidate characters in order they first appeared and skip those whose count $>1$.
- A queue (FIFO) of characters that might be non-repeating works well: push new char if seen first time; while queue front has count $>1$, pop it. The front (if any) is current first non-repeating.

**Pseudocode:**
```python
counts = empty hashmap (char -> int)
queue = empty queue
result = []

for ch in stream:
    counts[ch] += 1
    if counts[ch] == 1:
        queue.push(ch)
    while queue is not empty and counts[queue.front] > 1:
        queue.pop()
    if queue is empty:
        result.append(-1)
    else:
        result.append(queue.front)
return result
```

> **Why better than brute force:** We never re-scan the full prefix; each character is pushed at most once and popped at most once from the queue → linear time.

**Complexity:**
- **Time:** $O(n)$ — each char pushed/popped at most once, plus $O(1)$ hashmap updates.
- **Space:** $O(k)$ where $k$ is number of distinct characters in stream ($\leq \min(n, \text{alphabet size})$). Output $O(n)$.

**Small Example Walkthrough:**
- $s = "aabc"$
  - counts = { }, queue = [ ]
  - read 'a': counts['a']=1 → queue=['a'] → queue.front='a' → res['a']
  - read 'a': counts['a']=2 → queue still ['a'] but counts$>1$ so pop → queue empty → res[-1]
  - read 'b': counts['b']=1 → queue=['b'] → res['b']
  - read 'c': counts['c']=1 → queue=['b','c'] → queue.front='b' → res['b']

> This is the standard, practical solution for streaming — simple and fast.

---

### 4.3 Optimal — $O(n)$ Time, $O(k)$ Space (Queue + Counts) — Interview-Ready

This is the canonical optimal online approach. It's optimal in asymptotic time for a single-pass streaming solution and minimal conceptual complexity.

**Algorithm Summary:**
- Maintain a hashmap `counts` mapping char → frequency.
- Maintain a FIFO queue (deque) of characters in their first-seen order that might still be unique.
- For each incoming char `ch`:
  - Increment `counts[ch]`.
  - If `counts[ch] == 1`, push `ch` onto queue.
  - While queue not empty and `counts[queue[0]] > 1`, pop from left.
  - If queue empty → current first non-repeating is `-1`, else `queue[0]`.

**Python Code (clean, idiomatic, commented):**
```python
from collections import deque, defaultdict
from typing import List, Union

def first_non_repeating_stream(stream: str) -> List[Union[str, int]]:
    """
    For each prefix of `stream`, return the first non-repeating character,
    or -1 if none exists. Returns a list of length len(stream).
    """
    counts = defaultdict(int)   # char -> frequency seen so far
    q = deque()                 # candidates for first non-repeating (in order seen)
    result = []

    for ch in stream:
        counts[ch] += 1

        # If this is the first time we see ch, it's a candidate.
        if counts[ch] == 1:
            q.append(ch)

        # Remove front of queue while it's no longer non-repeating
        while q and counts[q[0]] > 1:
            q.popleft()

        # Report current first non-repeating (or -1)
        if q:
            result.append(q[0])
        else:
            result.append(-1)

    return result


# Quick manual test
if __name__ == "__main__":
    print(first_non_repeating_stream("aabc"))   # ['a', -1, 'b', 'b']
    print(first_non_repeating_stream("zz"))     # ['z', -1]
```

**Walkthrough on Example $s = "aabc"$**
- After 'a' → counts['a']=1, queue=['a'] → output 'a'
- After second 'a' → counts['a']=2, queue=['a'] but popped because counts$>1$ → queue empty → output -1
- After 'b' → counts['b']=1, queue=['b'] → output 'b'
- After 'c' → counts['c']=1, queue=['b','c'] → output 'b'

---

## 5. Edge Cases, Pitfalls, and Trade-offs

- **Sentinel choice:** We used `-1` as sentinel. In some problems they want `#` or `None`. Clarify with interviewer.
- **Repeated enqueues:** Only enqueue when `counts[ch] == 1`. If you enqueue every time (including repeats), you'd have duplicates in queue — avoid that.
- **Unicode vs limited alphabet:** For very large/unknown alphabets, `counts` may grow to size of distinct chars — that's unavoidable if you must track counts. If alphabet is fixed (e.g., lowercase letters), you can use an array of size 26 for slight memory/time improvement.
- **Memory/time trade-offs:** Queue + counts uses $O(k)$ space. Alternative fancy structures (like doubly-linked list + index mapping) can give $O(1)$ deletion if you needed to remove arbitrary nodes — but for this problem, queue + counts is simplest and fast.
- **Concurrent streams or parallel processing:** If multiple streams exist, maintain separate structures per stream.

**Alternative Optimal Methods (brief):**
- Use a doubly-linked list of currently unique characters plus a map from char→node to remove in $O(1)$ when it becomes repeating. Complexity still $O(n)$ time, $O(k)$ space. Helps when you want $O(1)$ removal without while-loop popping, but adds implementation complexity. For most interviews, queue+counts is accepted.

---

## 6. Follow-up / Extension Questions (Interviewer Style)

- **Follow-up 1:** Suppose the stream is unbounded and arrives extremely fast (millions/sec). How would you adapt the solution to use limited memory and still approximate the first non-repeating?
  - *Hint:* Consider approximate counting (e.g., Bloom-like sketches) or keep a time-decayed window. You can also restrict to a sliding window of last $W$ characters and maintain structure for that window.
- **Follow-up 2:** Modify the algorithm to return the $k$-th non-repeating character ($k \geq 1$) after each stream arrival (if exists).
  - *Hint:* Instead of always looking at queue front, you need quick access to the $k$-th unique — consider a doubly-linked list or order-statistics structure to get $k$-th active unique, or maintain a queue and an index mapping with occasional pruning.

---

## 7. Practice Problems (Related)

- **Easy:** First Unique Character in a String — Given a single string, return index of first non-repeating char. ([Leetcode 387](https://leetcode.com/problems/first-unique-character-in-a-string/))
- **Medium:** Design a data structure that supports `add(char)` and `getFirstUnique()` in $O(1)$ time. ([Leetcode 1429](https://leetcode.com/problems/first-unique-number/) — First Unique Number is variant)
- **Hard:** Given a stream and an integer $k$, find the $k$-th non-repeating character at every prefix (online). Optimize for time and memory.

---

## 8. Complexity Summary (Compact)

- **Brute Force:**
  - Time: $O(n^2)$
  - Space: $O(1)$ extra (or $O(k)$ if maintain freq array)
- **Improved (queue + counts) / Optimal:**
  - Time: $O(n)$
  - Space: $O(k)$ where $k$ = number of distinct characters ($\leq$ alphabet size or $n$)
- **Alternative (DLL + map):**
  - Time: $O(n)$
  - Space: $O(k)$; slightly better constant-time removal semantics, more complex to implement.

---

## 9. How to Speak in the Interview (Script + Tips)

**Tone & Structure:**
- Tone: Calm, confident, methodical. Speak slowly enough to let interviewer follow the logic.
- Structure your explanation: Problem → Clarify input/output/sentinel → Start with brute idea → Improve to optimal → Code/outline.

**Example Phrasing (Verbal Script):**
- **Start:**
  > "To restate: we receive characters one by one and after each arrival I need to report the first non-repeating character in the stream so far. I’ll assume we return -1 when there’s no such character — I can change that if you prefer another sentinel."
- **Brute force:**
  > "A brute force approach is, for every prefix, scan from left to right and find the first character whose frequency in the prefix is 1. That’s correct but it’s O(n²) and too slow for long streams."
- **Optimization insight:**
  > "We can do better by maintaining counts as we go and keeping candidates in the order they first appear. A queue is ideal because it preserves insertion order. When a character arrives, we increment its count; if the count becomes 1, push it to the queue. Then we pop from the front while the front is no longer unique. The front — if exists — is the first non-repeating."
- **Complexity summary:**
  > "This does a single pass and every character is enqueued and dequeued at most once, so it’s O(n) time and O(k) additional space, where k is the number of distinct characters."
- **Edge cases/trade-offs:**
  > "We should pick a sentinel for ‘no unique’. If the alphabet is very large or memory constrained, we might need to use approximate methods or a sliding window."

**Short Tips for Delivery:**
- First state assumptions (sentinel, alphabet). Interviewers value clarifying assumptions.
- Explain complexity at each stage.
- Write clean code and narrate important lines (e.g., “this while-loop removes invalid candidates”).

**Common Communication Mistakes & How to Avoid Them:**
- *Mistake:* Jumping into code without explaining the approach.
  - *Fix:* State your algorithm in 2–3 sentences first; then code.
- *Mistake:* Forgetting to state time/space complexity explicitly.
  - *Fix:* After explaining the approach, say “Time: … Space: …” out loud.

---

## 10. Final Quick Checklist to Memorize (Verbal Bullets)

- State the problem + sentinel.
- Brute idea: scan each prefix → $O(n^2)$.
- Key insight: maintain counts + FIFO of candidates.
- Algorithm: update count, append on first sight, pop while front freq$>1$, report front or -1.
- Complexity: $O(n)$ time, $O(k)$ space.
- Edge case: empty stream → return empty list; all repeating → return -1 for those prefixes.

---