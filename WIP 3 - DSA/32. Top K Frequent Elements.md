# Top K Frequent Elements — Study Guide (Interview coach style)

Short version: this guide teaches you how to reason about, implement, and communicate solutions for **Top K Frequent Elements** — a common interview problem. Read top-to-bottom: intuition, three-step approaches (Brute → Better → Optimal), interview-ready code, edge-cases, follow-ups, and how to *talk* while solving.

---

## 1) Problem restatement (1–2 sentences)

**Given:** an integer array `nums` and an integer `k`.
**Task:** return the `k` most frequent elements from `nums`. You may return the elements in any order.
**Constraints (typical):** `1 <= nums.length`, `k >= 1`, `k` is at most the number of unique elements.

---

## 2) Inputs / Outputs / Constraints (compact)

* **Input:** `nums: List[int]`, `k: int`
* **Output:** `List[int]` containing `k` integers (most frequent elements).
* **Limits to assume in interview:** `n = len(nums)` can be up to `10^5` or larger; aim for `O(n log n)` or better. Memory should be `O(n)` in worst-case (for frequency map).
* **Important:** If `k` equals number of unique elements, return all unique elements.

---

## 3) Motivating examples

| Example | Input                           | Output (one valid) | Explanation                                 |
| ------: | ------------------------------- | ------------------ | ------------------------------------------- |
|       1 | `nums=[1,1,1,2,2,3], k=2`       | `[1,2]`            | `1` appears 3 times, `2` appears 2 times.   |
|       2 | `nums=[1], k=1`                 | `[1]`              | Single element.                             |
|       3 | `nums=[4,4,4,6,6,2,2,2,3], k=2` | `[4,2]` or `[2,4]` | `4` and `2` both frequency 3; any order OK. |

Short explanations: build frequency counts, pick top-`k` by frequency. Ties can be broken arbitrarily unless specified.

---

## 4) Three-level approach: Brute → Better → Optimal

### A — Brute-force

**Intuition:** For each unique element, count its frequency (scan array each time) and then pick the top `k`.

**Pseudocode:**

```
unique = set(nums)
result = []
for each x in unique:
    count = count_occurrences(nums, x)   # scans entire list
    store (x, count)
sort stored pairs by count descending
return top k elements
```

**Complexity:**

* Time: `O(u * n + u log u)` where `u` = #unique (worst `u = n` → `O(n^2)`).
* Space: `O(u)`.

**Mini-walkthrough (nums=[1,1,2], k=1):**

* unique={1,2}. Count 1 → 2, Count 2 → 1. Sort → pick 1.

**One-line critique:** Too slow when `n` large — avoid rescanning `nums` repeatedly.

---

### B — Better (Hash map + full sort)

**Intuition:** Build a frequency map in one pass, then sort unique elements by frequency.

**Pseudocode:**

```
freq = {}
for num in nums:
    freq[num] = freq.get(num,0) + 1

pairs = list(freq.items())  # (num, count)
sort pairs by count descending
return first k numbers from sorted pairs
```

**Complexity:**

* Time: `O(n + u log u)` where `u` is #unique (sorting `u` items).
* Space: `O(u)`.

**Mini-walkthrough (nums=[1,1,1,2,2,3], k=2):**

* freq = {1:3, 2:2, 3:1} → pairs sorted [(1,3),(2,2),(3,1)] → return [1,2].

**One-line critique:** Simple and often acceptable; if `u` large (≈n) sorting cost `O(n log n)` may be excessive when `k` is small.

---

### C — Optimal (Hash map + heap or Bucket sort)

Two commonly used optimal solutions:

**Option 1 (Heap - good when k small):**

* Build freq map `O(n)`.
* Maintain a min-heap of size `k` keyed by frequency so you only keep top k.
* Time: `O(n + u log k)`. Space: `O(u)`.

**Option 2 (Bucket sort - best when frequency range small or to get linear):**

* Build freq map `O(n)`.
* Create buckets: array of length `n+1` where `buckets[f]` lists numbers with frequency `f`.
* Walk buckets from high freq → low, collect until k elements found.
* Time: `O(n)`. Space: `O(n)`.

We'll present both intuitions and pseudocode below.

#### C1 — Heap (min-heap of size k)

**Pseudocode:**

```
freq = build frequency map
heap = empty min-heap
for (num, count) in freq.items():
    if heap.size < k:
        push (count, num) into heap
    else if count > heap.peek().count:
        pop heap
        push (count, num)
# heap now contains k elements with largest counts
return [num for (count, num) in heap]
```

**Complexity:**

* Time: `O(n + u log k)`
* Space: `O(u)` (and `O(k)` heap)

**Mini-walkthrough (nums=[1,1,1,2,2,3], k=2):**

* freq {1:3,2:2,3:1}. Insert (3,1), (2,2) -> heap size 2. See (1,3) smaller than heap min (2) so skip. Result [1,2].

**One-line critique:** Best when `k << u`.

#### C2 — Bucket sort (linear)

**Pseudocode:**

```
freq = build frequency map
n = len(nums)
buckets = array of lists of size n+1  # index = frequency
for (num, count) in freq.items():
    append num to buckets[count]

result = []
for freqValue from n down to 1:
    for num in buckets[freqValue]:
        append num to result
        if len(result) == k:
            return result
```

**Complexity:**

* Time: `O(n)` (one pass to count + linear scan of buckets)
* Space: `O(n)` (buckets + map)

**Mini-walkthrough (nums=[1,1,1,2,2,3], k=2):**

* freq {1:3,2:2,3:1}. buckets[3]=[1], buckets[2]=[2], buckets[1]=[3]. Scan 6→3 → add 1; 2→ add 2 → done.

**One-line critique:** Clean `O(n)` solution; uses `O(n)` extra array but no sorting.

---

## 5) Interview-ready solution (Optimal) — Bucket sort (recommended)

I’ll present the bucket sort approach (linear time) — it's simple to explain and implements cleanly.

### Algorithm summary (plain english)

1. Count frequency of each element using a hash map (one pass over `nums`).
2. Create an array of lists `buckets` where index `i` holds all elements with frequency `i`.
3. Iterate `buckets` from high frequency to low, collecting elements until you have `k`.

This is `O(n)` time and `O(n)` space (worst-case), and straightforward to justify in an interview.

### Python implementation (clean + commented)

```python
def topKFrequent(nums: list[int], k: int) -> list[int]:
    """
    Return the k most frequent elements from nums.
    Uses bucket sort for O(n) time.
    """
    # 1) Frequency map
    freq: dict[int, int] = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1

    # 2) Buckets: index = frequency, value = list of numbers with that frequency.
    n = len(nums)
    buckets: list[list[int]] = [[] for _ in range(n + 1)]  # freq range: 0..n

    for num, count in freq.items():
        buckets[count].append(num)

    # 3) Collect top k from buckets, iterating from high freq to low.
    result: list[int] = []
    for frequency in range(n, 0, -1):          # highest possible frequency first
        if not buckets[frequency]:
            continue
        for num in buckets[frequency]:
            result.append(num)
            if len(result) == k:
                return result

    # Edge case: if k == 0 or something odd, but per problem k>=1.
    return result
```

### Step-by-step walkthrough (example)

`nums=[1,1,1,2,2,3], k=2`

* freq map → `{1:3, 2:2, 3:1}`.
* n = 6 → buckets length 7 (indices 0..6).
* Place `1` in `buckets[3]`, `2` in `buckets[2]`, `3` in `buckets[1]`.
* Iterate freq 6→1: at freq=3, buckets[3]=[1] → append `1` (result `[1]`); at freq=2 append `2` (result `[1,2]`) → reached k, return `[1,2]`.

### Complexity recap

* Time: `O(n)` to build map + `O(n)` to set up buckets and scan them → `O(n)`.
* Space: `O(n)` for frequency map + `O(n)` for buckets → `O(n)`.

---

## 6) Edge cases, pitfalls, and trade-offs

**Gotchas & how to avoid them**

* `k > number of unique elements`: decide behavior — usually return all unique elements. Check constraints; you can `k = min(k, len(freq))`.
* `k == 0` (if allowed): return `[]`.
* Negative `k` or non-integer `k`: validate input if interviewer expects robust code.
* Ties in frequency: problem usually allows any order; if deterministic order required, sort tied items by value or by first-seen position.
* Large `n` with small `k`: heap approach (`O(u log k)`) can be preferable for memory locality and when you must limit extra space.
* Memory pressure: bucket array size is `n+1`; if `n` huge and memory tight, prefer heap approach.

**Alternative optimal methods (short):**

* **Min-Heap of size `k`**: `O(n + u log k)` — better when `k` much smaller than `u`.
* **Selection algorithm (Quickselect on unique elements)**: average `O(u)` time; more complex to implement but avoids full sort and uses less extra space than bucket array; rarely needed in interviews for this problem.

---

## 7) Follow-ups & hints (two realistic follow-ups — **hints only**)

1. **Follow-up:** "What if the input is a real-time stream of numbers and you need to maintain top-k at any moment?"
   **Hint:** Maintain a frequency map and a data structure that updates top-k incrementally — consider an order-statistics tree or a heap keyed by frequency; update frequencies and push/pop in heap. Think about amortized cost of updates.

2. **Follow-up:** "Return top-k elements sorted by frequency (descending), and break ties by smallest value."
   **Hint:** After selecting candidates (via buckets or heap), perform a final sort with a custom key `( -frequency, value )`. Sorting only `k` items costs `O(k log k)`.

---

## 8) Practice problems (LeetCode preferred)

1. **Top K Frequent Elements** — Medium.
   [https://leetcode.com/problems/top-k-frequent-elements/](https://leetcode.com/problems/top-k-frequent-elements/)
2. **Frequency Sort** — Medium: sort characters by frequency.
   [https://leetcode.com/problems/sort-characters-by-frequency/](https://leetcode.com/problems/sort-characters-by-frequency/)
3. **Kth Largest Element in an Array** — Medium: related selection problem.
   [https://leetcode.com/problems/kth-largest-element-in-an-array/](https://leetcode.com/problems/kth-largest-element-in-an-array/)

(If the platform or URLs are blocked in the interview environment, search by problem title on your chosen platform.)

---

## 9) How to speak in the interview (mini coaching)

**Tone:** confident, structured, and collaborative. Narrate your thinking; invite feedback.

**What to say out loud (examples):**

* Start: “I’ll restate the problem briefly, list assumptions, and mention constraints I’ll use.”
* On approach: “A naive approach would recompute counts repeatedly — that’s `O(n^2)`. We can do better using a hash map to count frequencies in `O(n)`.”
* Choosing optimal: “Since we need top-k, two common optimal approaches are a min-heap of size `k` (`O(n log k)`) and bucket sort (`O(n)`). Because `k` may be large and we can afford `O(n)` extra space, I’ll implement bucket sort for its clarity and linear time.”
* While coding: narrate each block: “This block builds frequency map. Next I set up buckets indexed by frequency…”
* When finishing: “Complexities: time `O(n)`, space `O(n)`. Edge-cases: k>unique, ties handled arbitrarily; we can adjust if needed.”

**What to narrate while coding:**

* Variable purpose, loop invariants, why you choose a data structure.
* Point out early return conditions and validations.

**Common communication mistakes + fixes:**

* Mistake: diving into code with no plan. → Fix: always give a one-paragraph plan first.
* Mistake: silence for long while thinking. → Fix: narrate your thought process ("I'm thinking whether to use heap or bucket...").
* Mistake: neglecting edge cases. → Fix: explicitly mention and handle them before coding.
* Mistake: not discussing complexity. → Fix: after solution, summarize Big-O and trade-offs.

---

## 10) Quick checklist (what to say and do in an interview)

* Restate the problem & constraints (1–2 lines).
* Outline options (Brute → Better → Optimal) and choose one with reason.
* Mention algorithm, data structures, and Big-O before coding.
* Code clearly with small helper comments.
* Run through 1-2 examples and edge cases.
* Summarize complexity and trade-offs.
* Offer alternatives if time permits (heap vs bucket, selection alg).

---

### Supplement — Example heap implementation (if asked for heap)

```python
import heapq

def topKFrequent_heap(nums: list[int], k: int) -> list[int]:
    # freq map
    freq = {}
    for n in nums:
        freq[n] = freq.get(n, 0) + 1

    # min-heap of (count, num)
    heap = []
    for num, count in freq.items():
        if len(heap) < k:
            heapq.heappush(heap, (count, num))
        else:
            # if current count bigger than smallest in heap, replace it
            if count > heap[0][0]:
                heapq.heapreplace(heap, (count, num))

    # Extract elements from heap
    return [num for count, num in heap]
```

* Complexity: `O(n + u log k)`. Use when `k << u`.

