# Longest Consecutive Sequence ‚Äî Study Guide (DSA Interview Coach Style)

---

## üìë Index

- [Short Problem Restatement](#1-short-problem-restatement)
- [Inputs / Outputs / Constraints](#2-inputs--outputs--constraints)
- [Motivating Examples](#3-motivating-examples)
- [Three-Level Approach Teaching](#4-three-level-approach-teaching-brute--better--optimal)
  - [Brute Force](#brute-force)
  - [Better ‚Äî Hash + Visited Marking](#better-hash--visited-marking--partial-expansion)
  - [Optimal ‚Äî Hash-Set Start-of-Run](#optimal-canonical-hash-set-approach--start-of-run-detection)
- [Interview-Ready Solution (Optimal)](#5-interview-ready-solution-optimal)
- [Edge Cases, Pitfalls, and Trade-Offs](#6-edge-cases-pitfalls-and-trade-offs)
- [Follow-Ups & Hints](#7-follow-ups--hints-for-interview-discussion)
- [Practice Problems](#8-practice-problems)
- [How to Speak in the Interview](#9-how-to-speak-in-the-interview)
- [Quick Checklist](#10-quick-checklist-what-to-say--do-in-interview)
- [Expanded Follow-up Answers](#supplement--only-when-needed)
- [Follow-up 1 ‚Äî Real-time Stream](#follow-up-1--real-time-stream-of-log-dates-unbounded)
- [Follow-up 2 ‚Äî Compact Missing-Day Ranges](#follow-up-2--return-compact-missing-day-ranges-instead-of-every-missing-date)
- [Common Pitfalls (Summary)](#short-checklist-to-say-in-interview-for-both-follow-ups)

---

## 1) Short problem restatement

**Given:** an *unsorted* list of logged days (e.g. date strings `"YYYY-MM-DD"` or integer day IDs) representing days when a system produced logs.
**Task:** (a) compute the length of the **longest run** of consecutive days present in the logs; and (b) (practical extra) list which calendar days are **missing** between the earliest and latest logged day.
**Constraints:** input may contain duplicates, unsorted entries, and can be large (aim for *O(n)* time and *O(n)* extra space).

---

## 2) Inputs / Outputs / Constraints

* **Input:** `logs: List[str]` ‚Äî e.g. `["2025-11-01","2025-11-03","2025-11-02", ...]` (ISO date strings) *or* integer day IDs.
* **Output (1):** an integer `longest_streak` (length of longest consecutive-days run).
* **Output (2):** `missing_days: List[str]` ‚Äî sorted list of date strings for days between min and max that are not present in `logs`.
* **Limits:** `n = len(logs)` up to millions; duplicates allowed; memory for an auxiliary set of size ~n is acceptable.

---

## 3) Motivating examples

| Input (dates)                              | Longest streak | Missing days (between min and max) |
| ------------------------------------------ | -------------: | ---------------------------------- |
| `["2025-11-01","2025-11-03","2025-11-02"]` |            `3` | `[]`                               |
| `["2025-11-01","2025-11-03","2025-11-05"]` |            `1` | `["2025-11-02","2025-11-04"]`      |
| `["2025-10-29","2025-10-30","2025-11-02"]` |  `2` (`29-30`) | `["2025-10-31","2025-11-01"]`      |

**Short explanation:** convert inputs into a set for O(1) membership checks. For longest streak, expand from starts of runs only. For missing days, scan from min to max and collect days not in set.

---

## 4) Three-level approach teaching (Brute ‚Üí Better ‚Üí Optimal)

### Brute force

**Intuition:** Sort the dates and then scan to find longest consecutive run. Also for missing days, after sorting, compare adjacent days and fill gaps.

**Pseudocode**

```
convert date strings to day numbers (or datetime objects)
sort day_list ascending
longest = 0
for i from 0 to n-1:
    length = 1
    while i+1 < n and day[i+1] == day[i]+1:
        length += 1
        i += 1
    longest = max(longest, length)
# To get missing days: for each adjacent pair, add days in gap
```

**Complexity**

* Time: O(n log n) due to sorting.
* Space: O(n) for converted list (in-place sort aside).

**Worked mini-walkthrough**
Input `["1","3","2"]` ‚Üí convert ‚Üí `[1,3,2]` ‚Üí sort ‚Üí `[1,2,3]` ‚Üí scan ‚Üí longest = 3.

**One-line critique:** Simple and robust, but sorting is unnecessary if we can do linear-time.

---

### Better (Hash + visited marking / partial expansion)

**Intuition:** Use a hash set so you can check membership in O(1); for each element, expand left & right but mark visited so you don't do work twice.

**Pseudocode**

```
set = set(all days)
visited = empty set
for day in set:
    if day in visited: continue
    # expand both directions, marking visited
    left = day-1; while left in set: visited.add(left); left -= 1
    right = day+1; while right in set: visited.add(right); right += 1
    length = right - left - 1
    update longest
```

**Complexity**

* Time: O(n) amortized (each day visited once).
* Space: O(n) for set + visited.

**Mini-walkthrough**
Set `{1,2,3}`; pick `1`: expand right to 3, mark {1,2,3}; length = 3.

**One-line critique:** Works in linear time but requires careful visited bookkeeping; more bookkeeping than the canonical optimal.

---

### Optimal (Canonical hash-set approach ‚Äî start-of-run detection)

**Intuition (plain language):** Put all days into a set. A day is the *start* of a consecutive run if its predecessor (day-1) is not in the set. For starts, expand forward (day+1, day+2, ...) counting consecutive entries. This ensures each element is considered at most once ‚Äî O(n).

**Pseudocode**

```
set = set(all days)
longest = 0
for day in set:
    if day - 1 not in set: # start of run
        current = day
        length = 1
        while current + 1 in set:
            current += 1
            length += 1
        longest = max(longest, length)
return longest
```

**Complexity**

* Time: O(n) average (each day checked constant times).
* Space: O(n) additional.

**Mini-walkthrough**
Input `{3,1,2,5}`: check `1`: 0 not in set ‚Üí expand to 3 ‚Üí length=3; check `5`: 4 not in set ‚Üí expand length=1 ‚Üí result 3.

**One-line critique:** Elegant and minimal bookkeeping; the typical interview answer.

---

## 5) Interview-ready solution (Optimal)

### Algorithm summary (plain English)

1. Normalize input to integer day IDs (or `date.toordinal()` if dates).
2. Insert all day IDs into a set (removing duplicates).
3. For each day in the set, if `(day - 1)` is **not** in the set, this day starts a run ‚Äî walk forward counting `(day+1, day+2, ...)` while they're present. Track max length.
4. (Practical extra) To get missing days between earliest and latest day: iterate from min to max and collect days not in the set (or produce ranges if you prefer concision).

### Well-commented Python implementation

```python
from datetime import datetime, timedelta
from typing import List, Tuple

def iso_to_ordinal(date_str: str) -> int:
    """Convert 'YYYY-MM-DD' to integer day count (ordinal)."""
    return datetime.strptime(date_str, "%Y-%m-%d").date().toordinal()

def ordinal_to_iso(ordinal: int) -> str:
    """Convert ordinal back to 'YYYY-MM-DD'."""
    return datetime.fromordinal(ordinal).date().isoformat()

def longest_consecutive_and_missing(log_dates: List[str]) -> Tuple[int, List[str]]:
    """
    Returns (longest_streak, missing_days_list).
    - longest_streak: length of longest consecutive-day run in logs.
    - missing_days_list: sorted list of ISO date strings missing between min and max logged day.
    """
    if not log_dates:
        return 0, []

    # Convert to ordinals (integers) to do arithmetic easily.
    ordinals = [iso_to_ordinal(d) for d in log_dates]
    day_set = set(ordinals)  # de-duplicate & O(1) membership

    # --- Part A: longest consecutive run (optimal O(n) approach) ---
    longest = 0
    for day in day_set:
        # Only start counting if `day-1` is NOT present (start of a run)
        if (day - 1) not in day_set:
            length = 1
            current = day
            # Expand forward while consecutive days exist
            while (current + 1) in day_set:
                current += 1
                length += 1
            if length > longest:
                longest = length

    # --- Part B: list missing days between min and max (practical) ---
    min_day, max_day = min(day_set), max(day_set)
    missing_ordinals = [d for d in range(min_day, max_day + 1) if d not in day_set]
    missing_dates_iso = [ordinal_to_iso(o) for o in missing_ordinals]

    return longest, missing_dates_iso


# Example usage
if __name__ == "__main__":
    logs = ["2025-11-01", "2025-11-03", "2025-11-05", "2025-11-02"]
    longest, missing = longest_consecutive_and_missing(logs)
    print("Longest streak:", longest)          # -> 3 (Nov 1-3)
    print("Missing days:", missing)            # -> ['2025-11-04']
```

### Step-by-step walkthrough on `["2025-11-01","2025-11-03","2025-11-05","2025-11-02"]`

1. Convert to ordinals: `[ordinal(2025-11-01), ordinal(2025-11-03), ordinal(2025-11-05), ordinal(2025-11-02)]`.
2. `day_set` = `{ord(2025-11-01), ord(2025-11-02), ord(2025-11-03), ord(2025-11-05)}`.
3. For each day:

   * For `ord(2025-11-01)`: predecessor not in set ‚Üí expand to 02 and 03 ‚Üí length = 3 ‚Üí `longest = 3`.
   * For `ord(2025-11-02)` and `03`: skip starting check because predecessor present.
   * For `ord(2025-11-05)`: predecessor `04` not in set ‚Üí length = 1.
4. `min_day` = `ord(2025-11-01)`, `max_day` = `ord(2025-11-05)`. Range includes 01‚Äì05; missing ordinals correspond to `2025-11-04`.
5. Return `(3, ["2025-11-04"])`.

### Complexity recap

* **Time:** O(n) average (set construction O(n) + scanning set O(n)).
* **Space:** O(n) extra for the set and ordinals.

---

## 6) Edge cases, pitfalls, and trade-offs

* **Duplicates:** input may contain duplicates ‚Äî use a set to deduplicate.
* **Non-uniform input types:** handle both ISO date strings and integer day IDs; unify early.
* **Large ranges:** if `min` and `max` are far apart (years) and you need *missing days*, iterating every day could be expensive or memory-heavy ‚Äî prefer yielding ranges (e.g., `2025-01-05 -> 2025-02-10`) or streaming results rather than building a huge list.
* **Timezones / daylight savings:** use date-only values (no time-of-day) to avoid DST/timezone issues; clarify with product whether logs are UTC.
* **Memory limits:** the O(n) set requires memory proportional to unique days; for extremely large n or streaming inputs, consider external sorting or streaming algorithms with windows.
* **Input validation:** invalid date strings will throw; either validate or fail-fast with a clear message.

**Alternative optimal methods (short):**

* Use a union-find (disjoint set) structure to merge consecutive elements ‚Äî gives near-linear time but more overhead and complexity.
* For streaming logs, keep a sliding window + approximate membership (Bloom filter) or maintain active streaks in a priority structure ‚Äî trade accuracy or complexity.

---

## 7) Follow-ups & hints (for interview discussion)

1. **Follow-up:** *What if the input is a **real-time stream** of log dates (unbounded)?*
   **Hint:** Keep recent windows; maintain active runs with a hashmap keyed by run endpoints; evict old data using time-based retention; consider emitting completed runs when you detect gaps longer than retention.
2. **Follow-up:** *How to return compact missing-day **ranges** instead of every missing date?*
   **Hint:** While scanning from `min` to `max`, convert contiguous missing ordinals into `(start,end)` ranges; output as `["2025-11-04"]` or `["2025-11-04->2025-11-10"]`.

---

## 8) Practice problems

1. **LeetCode 128 ‚Äî Longest Consecutive Sequence** (Medium) ‚Äî the exact core problem for run detection.
2. **LeetCode 163 ‚Äî Missing Ranges** (Easy/Medium) ‚Äî find ranges missing in a sorted array (conceptually similar to missing-date ranges).
3. **LeetCode 448 ‚Äî Find All Numbers Disappeared in an Array** (Easy) ‚Äî find missing elements in `1..n` using in-place techniques (good for memory-constrained variants).

*(If you're interviewing, mention these exact IDs / problem names ‚Äî many interviewers know them.)*

---

## 9) How to speak in the interview

* **Tone:** calm, structured, and deliberate. Start with a short restatement: *‚ÄúI'll restate: we have unsorted dates, need the longest consecutive run; clarify if inputs are date-only or timestamp ‚Äî I‚Äôll assume date-only ISO strings.‚Äù*
* **Example phrases while thinking:**

  * ‚ÄúMy baseline is sorting ‚Äî that gives O(n log n). I think we can do better using a hash set for O(n).‚Äù
  * ‚ÄúI will convert dates to integers (ordinals) so arithmetic is simple.‚Äù
  * ‚ÄúTo avoid repeated work, only start expanding runs from elements that don‚Äôt have a predecessor in the set.‚Äù
* **When coding:** narrate high-level steps then code. Example: ‚ÄúI'll first normalize inputs, build the set, then loop to find starts of runs, expanding forward.‚Äù
* **Common communication mistakes + fixes:**

  * *Mistake:* jumping to code without stating complexity. ‚Äî *Fix:* state approach & complexity first.
  * *Mistake:* not handling duplicates / empty input. ‚Äî *Fix:* explicitly mention and show de-duplication and empty checks.
  * *Mistake:* ignoring extreme ranges when listing missing days. ‚Äî *Fix:* note trade-offs (range vs per-day listing).

---

## 10) Quick checklist (what to say & do in interview)

* Restate problem and assumptions (date format, timezone, duplicates).
* Mention naive sorting solution and its O(n log n) cost.
* Propose O(n) hash-set approach; explain "start-of-run" idea.
* Convert dates to ordinals for arithmetic; dedupe with a set.
* Code cleanly, comment key lines, handle empty input.
* Mention edge-cases (large ranges, streaming, timezones) and alternatives.

---

### Supplement ‚Äî only when needed

If you need an implementation that **streams** logs and keeps approximate longest streak with constant memory, I can sketch a streaming design (using time-windowed state, bounded retention, and eviction policies). Ask for the streaming variant and I‚Äôll give a concise design.

Nice ‚Äî I‚Äôll expand both follow-ups into interview-ready, detailed answers: clear approaches, data structures, pseudocode / Python, complexity, trade-offs, test cases, and what to say aloud during an interview. I‚Äôll treat them separately.

---

# Follow-up 1 ‚Äî **Real-time stream of log dates (unbounded)**

## Problem restatement (stream view)

You receive an unbounded stream of log **dates** (date-only or day IDs), one record at a time, in near-real time. You must maintain (a) the current longest consecutive streak seen so far (and possibly emit updates as it grows), and (b) optionally detect and emit *completed* runs or missing-day information ‚Äî all while memory is bounded by a retention policy.

> Key constraints you should state: stream is unbounded; logs may arrive out-of-order or delayed; you must bound memory (can't keep every historical day forever); you may be allowed to trade completeness for bounded memory and latency.

---

## Goals & design questions to clarify (state these in interview)

* Do we need **exact** global longest streak across all time, or longest within a **sliding window** (e.g., 90 days)?
* Must we support **out-of-order** arrivals? If so, how late can events arrive?
* Do we need to emit completed runs when they're finished or just keep updating the best-so-far?

(You don‚Äôt need the user to answer in an interview ‚Äî propose reasonable assumptions, then give both exact-with-bounded-retention and approximate/streaming variants.)

---

## Two practical designs (choose by requirement)

### A. **Sliding-window exact solution** (bounded memory, exact within window)

Use when stakeholder says: ‚ÄúWe only care about last `W` days (e.g., 90 days).‚Äù

**Idea:** keep only days inside `[now - W, now]`. Maintain an interval set representing active runs inside window. Use two hash maps mapping interval endpoints: `start_to_end` and `end_to_start`. Also keep a max-length tracker (max-heap or balanced tree keyed by length) to report the longest run within the window. Evict days as they fall out of the window and merge/trim intervals if needed.

**Data structures**

* `start_to_end: dict[int -> int]` (start_ordinal ‚Üí end_ordinal)
* `end_to_start: dict[int -> int]` (end_ordinal ‚Üí start_ordinal)
* `lengths_maxheap` or `sorted container` keyed by interval length (to quickly get current longest)
* `arrival_min_heap` of (day_ordinal, arrival_time) or simply rely on periodic window eviction using current time

**Stream insert algorithm (for one incoming day `d`)**

1. If `d` already present in any interval (check via neighbor lookups), ignore.
2. Check `d-1` in `end_to_start` and `d+1` in `start_to_end`:

   * If both exist: merge left interval `[L, d-1]` and right `[d+1, R]` into `[L, R]`. Update maps, update length structure.
   * Else if left exists: extend left to `[L, d]`.
   * Else if right exists: extend right to `[d, R]` with new start `d`.
   * Else: create new interval `[d, d]`.
3. Update max-length structure.
4. Periodically (or per-event if low throughput) evict days/interval portions older than `now - W`: if an interval partially falls outside window, trim it; if completely outside, remove and update max structure.

**Complexity**

* Per insert: O(log m) if using heap/ordered structure for lengths (m = number of intervals). Hash ops O(1).
* Memory: O(k) where k = unique days in window (worst-case W).

**Pros / Cons**

* Pro: exact within window.
* Con: Needs eviction logic and ordered structure to maintain max; slightly complex implementation.

**Interview phrasing**

* ‚ÄúI‚Äôll assume the product wants correctness for a sliding window; we can maintain endpoint maps and a max structure to keep longest interval in the window. We trim intervals as time moves forward.‚Äù

---

### B. **Unbounded stream, approximate / emit-completed-runs design** (bounded memory, best-effort)

Use when you can‚Äôt store all history and you‚Äôre allowed to *emit* completed runs once you are confident they‚Äôre finished.

**Idea:** keep active runs for *recent* days and emit a run as ‚Äúcompleted‚Äù only if there has been a gap of `G` days (or time) with no arrivals that could extend that run. Use retention `R` and completion delay `G` (a tunable parameter).

**Data structures**

* `active_runs` maps endpoints like in (A).
* A TTL/expiry heap keyed by last-seen time for days/intervals.
* Optional persistent store (key-value DB) for older summarized intervals.

**Stream algorithm**

1. For each incoming day `d`:

   * Merge with active runs as in (A).
   * Update `last_seen` timestamp for affected interval.
2. Periodically (every T seconds) scan `active_runs` and for any interval where `now - last_seen > G`, mark it *completed* and either:

   * Emit the interval to downstream (e.g., "completed run [start,end] length L at time t"), then delete from `active_runs` (or move to persistent store).
   * Or snapshot it to a compact summary store.
3. Use retention R to drop intervals older than R (move to disk or delete).

**Complexity**

* Per insert O(1) merges + occasional O(log n) for heap maintenance. Memory is bounded by active runs count (tunable by R/G).

**Why this is practical**

* Streams often have delays but not indefinitely long ones. By waiting `G` days without extension, we can safely treat a run as finished with high confidence. This allows bounded memory while still producing useful concrete results.

**Interview phrasing**

* ‚ÄúFor unbounded streams I‚Äôd use time-based eviction and a safe completion delay `G`: keep active runs for recent time, emit runs only after they haven‚Äôt been extended for `G` days. That gives a practical trade-off between memory and timeliness.‚Äù

---

### C. **In-memory dynamic merge (exact unbounded but needs unbounded memory)**

If the interviewer insists on exact across all time and unbounded memory: use the canonical boundary-merge hash method (maps `start->end` and `end->start`) used for dynamic integer set union. This is exactly the in-memory generalization of the batch O(n) algorithm for inserts. Complexity is O(1) average per insert, but memory grows with unique days seen ‚Äî mention this caveat.

---

## Example streaming pseudocode (sliding-window exact)

```python
# Pseudocode snippet (Python-like) ‚Äî sliding window exact
from heapq import heappush, heappop
start_to_end = {}
end_to_start = {}
# max_lengths can be a max-heap of (-length, start, end) with lazy deletion
max_heap = []
# mapping to detect if day already in interval: we can keep a set of active ordinals
active_set = set()

def insert_day(d_ordinal, now_ts):
    if d_ordinal in active_set:
        return
    left_exists = (d_ordinal - 1) in end_to_start
    right_exists = (d_ordinal + 1) in start_to_end

    if left_exists and right_exists:
        L = end_to_start.pop(d_ordinal - 1)
        R = start_to_end.pop(d_ordinal + 1)
        # merge to [L, R]
        start_to_end[L] = R
        end_to_start[R] = L
        # mark ordinals in active_set accordingly (or use interval tracking)
        heappush(max_heap, (-(R-L+1), L, R))
    elif left_exists:
        L = end_to_start.pop(d_ordinal - 1)
        start_to_end[L] = d_ordinal
        end_to_start[d_ordinal] = L
        heappush(max_heap, (-(d_ordinal-L+1), L, d_ordinal))
    elif right_exists:
        R = start_to_end.pop(d_ordinal + 1)
        start_to_end[d_ordinal] = R
        end_to_start[R] = d_ordinal
        heappush(max_heap, (-(R-d_ordinal+1), d_ordinal, R))
    else:
        start_to_end[d_ordinal] = d_ordinal
        end_to_start[d_ordinal] = d_ordinal
        heappush(max_heap, (-1, d_ordinal, d_ordinal))
    active_set.add(d_ordinal)
```

Eviction logic trims/ splits intervals when the left portion falls out of window.

---

## Tests / scenarios to show interviewer

1. **On-order stream that grows a single run:** insert 1,2,3 ‚Üí longest updates 1‚Üí2‚Üí3.
2. **Out-of-order arrival:** insert 3,1,2 ‚Üí after inserting 3 longest=1; after 1 longest=1; after 2 merges to 3.
3. **Late arrival extending an old run:** run emitted as completed after `G` days then a late day arrives; you must decide whether to allow re-opening runs or accept late-arrival miss (document behavior).
4. **Eviction effect:** with W=5, insert 1..6 over time; show trimming of interval left part as 1 falls out.

---

## Trade-offs / what to say in interview

* State trade-offs: exact unbounded = unbounded memory; bounded memory requires sliding-window or completion-delay strategy.
* Discuss late arrivals: define policies (accept and merge back? treat as new run? emit correction events?).
* Mention durability: for real systems persist interval summaries to a database so restarts do not lose state.

---

# Follow-up 2 ‚Äî **Return compact missing-day ranges instead of every missing date**

## Problem restatement

Given `min` and `max` date ordinals and a set of present day ordinals, return a compact representation of missing days as **ranges** like `["2025-11-04"]` for single days or `["2025-11-04->2025-11-10"]` for stretches.

---

## Algorithm (simple, efficient)

1. Compute `min_day` and `max_day`.
2. Iterate ordinal `d` from `min_day` to `max_day`. When you encounter `d` not in `present_set`, start a missing-range `start = d`. Advance `d` until you find a day that *is* present (or exceed `max_day`), set `end = d-1`. Emit range `(start,end)` and continue. Use `while` loop to skip the inner days; complexity is O(R + P) where R = number of days in range (but you iterate at most `max-min+1` once).

**This is linear in the span length (max-min).** If the calendar span is huge (years) but present_set is small, it's expensive. For huge spans prefer **gap-by-gap scanning** using sorted present days: iterate over sorted present days and produce gaps between consecutive present days ‚Äî this only touches present days and the gap endpoints, not every day in the huge span.

### Optimal method for large spans (recommended)

* Sort the unique present ordinals into a list `sorted_present`.
* Let `prev = min_day - 1`. For each `p` in `sorted_present`:

  * If `p > prev + 1`: missing range is `(prev + 1, p - 1)`.
  * Set `prev = p`.
* After loop if `prev < max_day`: emit `(prev + 1, max_day)`.

This touches only `unique_present_count`, not every day in the range.

---

## Pseudocode (range-by-sorted-present)

```
sorted_present = sorted(unique_present)
result = []
prev = min_day - 1
for p in sorted_present:
    if p > prev + 1:
        result.append((prev + 1, p - 1))
    prev = p
if prev < max_day:
    result.append((prev + 1, max_day))
# convert ranges to desired string format
```

**Complexity**

* Sorting `sorted_present`: O(k log k) for k unique present days.
* Iteration: O(k).
* Space: O(k) + output size.

This is best when `max - min` is potentially huge but `k` is small.

---

## Python implementation (compact, interview-ready)

```python
from datetime import datetime

def ordinal_to_iso(ordinal: int) -> str:
    return datetime.fromordinal(ordinal).date().isoformat()

def compact_missing_ranges(present_ordinals: set, min_day: int, max_day: int):
    if min_day > max_day:
        return []
    # Use sorted present ordinals that lie within [min_day, max_day]
    sorted_present = sorted(x for x in present_ordinals if min_day <= x <= max_day)
    result = []
    prev = min_day - 1
    for p in sorted_present:
        if p > prev + 1:
            start, end = prev + 1, p - 1
            if start == end:
                result.append(ordinal_to_iso(start))
            else:
                result.append(f"{ordinal_to_iso(start)}->{ordinal_to_iso(end)}")
        prev = p
    # tail gap
    if prev < max_day:
        start, end = prev + 1, max_day
        result.append(ordinal_to_iso(start) if start == end else f"{ordinal_to_iso(start)}->{ordinal_to_iso(end)}")
    return result

# Example:
present = {datetime(2025,11,1).date().toordinal(), datetime(2025,11,3).date().toordinal(), datetime(2025,11,5).date().toordinal()}
min_day = min(present); max_day = max(present)
print(compact_missing_ranges(present, min_day, max_day))
# -> ['2025-11-02','2025-11-04']
```

---

## Example runs & edge cases

1. Consecutive present days: no ranges emitted (empty list).
2. Single missing day between present days: emitted as single date `"2025-11-04"`.
3. Long missing stretch: emitted as `"2025-11-04->2025-11-10"`.
4. All days missing (present set empty): one range `min->max`.
5. Present includes values outside `[min,max]`: filtered out.

---

## When to use which method (every-day scan vs sorted-present gaps)

* If `max - min` is small (small calendar window), simply iterating day-by-day is fine (O(range)). Simple to implement.
* If `max - min` can be large (years) and `k` (present days) is small, sort present days and emit gaps ‚Äî avoids iterating every day (O(k log k) due to sort).

**Interview phrasing**

* ‚ÄúTo avoid iterating over a huge multi-year range, I‚Äôll sort the present days and compute gaps between consecutive present days; that way complexity depends on number of logged days rather than the time span.‚Äù

---

# Combined: streaming + compact-gap reporting

If you must support both streaming and compact-gap outputs (e.g., someone requests missing-day ranges for a window), combine the sliding-window interval set with a function that converts the complement of intervals into ranges quickly:

* If you maintain `start_to_end` intervals for the window, you can produce missing ranges by scanning interval endpoints: the gaps between consecutive intervals are the missing ranges ‚Äî *no day-by-day scan* necessary.

**How to compute missing ranges from stored intervals**

1. Sort intervals by start.
2. For `i` from 0..m-2, missing range between `interval[i].end + 1` to `interval[i+1].start - 1` if `end+1 <= start-1`.
3. Consider prefix (min_day -> first_interval.start-1) and suffix similarly.

This is efficient because `m` is number of intervals, typically small when logs are dense.

---

# Suggested interview talking points for these follow-ups

* State assumptions (window size, tolerance for late arrivals, memory bounds).
* Present two concrete designs (sliding-window exact; completion-delay emit-and-drop), explain complexity and trade-offs.
* Show how interval endpoint maps allow O(1) merges on insert.
* For missing ranges, present both naive (per-day) and efficient (sort present or use stored intervals) solutions and explain when to use each.
* Discuss late arrival policies and how to correct or re-emit previously emitted runs if required.

---

# Short checklist to say in interview (for both follow-ups)

* ‚ÄúAssume date-only ordinals and dedupe early.‚Äù
* ‚ÄúFor unbounded streams use windowed retention or completion-delay to bound memory.‚Äù
* ‚ÄúRepresent runs as intervals with `start->end` and `end->start` maps for O(1) merges.‚Äù
* ‚ÄúEmit completed runs after safe delay `G` or persist to DB for later reconciliation.‚Äù
* ‚ÄúTo return compact missing-day ranges, sort present days (O(k log k)) or compute gaps between stored intervals (O(m log m)).‚Äù

