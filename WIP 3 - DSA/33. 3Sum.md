# 3Sum — Interview Guidance Coach (Guide-style)

---

## Short problem restatement

**Given:** an array of integers.
**Task:** find all unique triplets `[a, b, c]` in the array such that `a + b + c == 0`. Triplets should be returned without duplicates (order within a triplet doesn't matter).
**Constraints (typical / assumed):** array length `n` is moderate (e.g., up to a few thousands), integers can be negative/positive/zero. Time complexity better than `O(n³)` is expected in interviews.

---

## Inputs / Outputs / Constraints (quick bullets)

* **Input:** `nums: List[int]` — possibly unsorted, can contain duplicates, negative and positive integers.
* **Output:** `List[List[int]]` — list of unique triplets, each triplet is a list of three integers.
* **Important constraints to mention in interview:** avoid duplicate triplets, output order doesn't matter, aim for `O(n²)` time and `O(1)` extra space (aside from output) where possible.

---

## Motivating examples

| Input              |                 Output | Short explanation                                            |
| ------------------ | ---------------------: | ------------------------------------------------------------ |
| `[-1,0,1,2,-1,-4]` | `[[-1,-1,2],[-1,0,1]]` | two distinct triplets sum to 0; duplicates in input handled. |
| `[0,0,0,0]`        |            `[[0,0,0]]` | many zeros but only one unique triplet.                      |
| `[1,2,-2,-1]`      |                   `[]` | no triplet sums to zero.                                     |

A quick explanation for the first: after sorting `[-4,-1,-1,0,1,2]`, two-pointer search centered at each element finds `[-1,-1,2]` and `[-1,0,1]`.

---

## Three-level approach teaching (Brute → Better → Optimal)

### 1) Brute force (naive)

**Intuition:** Try every combination of three indices `(i,j,k)` and check if sum is zero. Simple and correct, but slow.

**Pseudocode**

```
for i from 0 to n-3:
  for j from i+1 to n-2:
    for k from j+1 to n-1:
      if nums[i] + nums[j] + nums[k] == 0:
        add sorted([nums[i], nums[j], nums[k]]) to result_set
return list(result_set)
```

**Complexity**

* Time: `O(n^3)`
* Space: `O(result)` or `O(n^3)` if naive storage of duplicates; using a set to deduplicate costs extra.

**Mini-walkthrough**
Input `[ -1, 0, 1 ]` — single triplet checked once; works.

**One-line critique:** Too slow for `n` beyond ~200; interviewers expect better.

---

### 2) Better (hash-based two-sum per element)

**Intuition:** For each index `i`, you reduce to Two Sum on the remaining array: find pairs `j,k` such that `nums[j] + nums[k] = -nums[i]`. Use a hash set to get `O(n)` for each fixed `i`, deduplicate results.

**Pseudocode**

```
result_set = empty set
for i from 0 to n-1:
  target = -nums[i]
  seen = empty set
  for j from i+1 to n-1:
    if (target - nums[j]) in seen:
      add sorted([nums[i], nums[j], target - nums[j]]) to result_set
    add nums[j] to seen
return list(result_set)
```

**Complexity**

* Time: `O(n^2)` on average
* Space: `O(n)` extra for `seen` plus result storage

**Mini-walkthrough**
Input `[ -1, 0, 1, 2 ]`, `i=0 (nums[i]=-1)`: target `1`, iterate j=1..3; when j=2 (nums[j]=1) `target - nums[j] = 0` not in seen; but when j=3 (2) `target-2=-1` in seen? depends — shows approach works but deduplication carefulness needed.

**One-line critique:** `O(n^2)` average but extra `O(n)` space; deduplicating and symmetry handling can be fiddly.

---

### 3) Optimal (sort + two pointers) — *Interview-ready*

**Intuition (plain):** Sort the array. For each element `nums[i]` (as the first of the triplet), use a two-pointer scan (`left = i+1`, `right = n-1`) to find pairs whose sum equals `-nums[i]`. Sorting lets us skip duplicates easily and perform pair search in `O(n)` per `i`, giving `O(n^2)` overall.

**Pseudocode**

```
sort nums
result = []
for i in 0..n-3:
  if i > 0 and nums[i] == nums[i-1]:
    continue   // skip duplicate first element
  left = i + 1
  right = n - 1
  while left < right:
    s = nums[i] + nums[left] + nums[right]
    if s == 0:
      add [nums[i], nums[left], nums[right]] to result
      // skip duplicates for left and right
      while left < right and nums[left] == nums[left+1]: left += 1
      while left < right and nums[right] == nums[right-1]: right -= 1
      left += 1
      right -= 1
    elif s < 0:
      left += 1
    else:
      right -= 1
return result
```

**Complexity**

* Time: `O(n log n)` for sort + `O(n^2)` for loops → **`O(n^2)` overall**
* Space: `O(1)` extra (not counting result), or `O(k)` where `k` is number of triplets returned

**Mini-walkthrough**
Input `[-1,0,1,2,-1,-4]`:

* Sort → `[-4,-1,-1,0,1,2]`.
* `i=0 (-4)`: left=1 (-1), right=5 (2) → sum=-3 → left++ ... no triplet.
* `i=1 (-1)`: left=2 (-1), right=5 (2) → sum=0 → record `[-1,-1,2]`, skip duplicates, move pointers → find `[-1,0,1]`.
* `i=2` is -1 but skip because same as previous `i`.
  Result `[[ -1, -1, 2 ], [ -1, 0, 1 ]]`.

**One-line critique:** Best practical approach: optimal time, minimal extra space, and easy to explain and code in interviews.

---

## Interview-ready solution (Optimal)

### Algorithm summary (plain English)

1. Sort the array so duplicates are adjacent and we can use two pointers.
2. Iterate `i` over the array as the first member of the triplet. Skip duplicate `nums[i]` values.
3. For each `i`, place `left = i+1` and `right = n-1`. Move pointers inward:

   * If sum < 0, increment `left` to increase sum.
   * If sum > 0, decrement `right` to decrease sum.
   * If sum == 0, record triplet and move both pointers while skipping duplicates.
4. Continue until `left >= right`. Repeat for next `i`.
5. Return collected triplets.

### Clean, well-commented Python implementation

```python
from typing import List

def three_sum(nums: List[int]) -> List[List[int]]:
    """
    Return all unique triplets [a,b,c] such that a + b + c == 0.
    Uses sorting + two pointers: O(n^2) time, O(1) extra space (excluding result).
    """
    nums.sort()
    n = len(nums)
    result = []

    for i in range(n - 2):
        # Skip duplicate first elements to avoid duplicate triplets
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        # Two-pointer search for pair summing to -nums[i]
        target = -nums[i]
        left, right = i + 1, n - 1

        while left < right:
            s = nums[left] + nums[right]
            if s == target:
                # Found a valid triplet
                result.append([nums[i], nums[left], nums[right]])

                # Move left pointer past duplicates
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Move right pointer past duplicates
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1

                # Move both to continue searching
                left += 1
                right -= 1

            elif s < target:
                # Need a larger sum -> move left forward
                left += 1
            else:
                # Need a smaller sum -> move right backward
                right -= 1

    return result
```

### Step-by-step walkthrough on `[-1,0,1,2,-1,-4]`

1. Sort → `[-4, -1, -1, 0, 1, 2]`.
2. `i=0` (`-4`): `target=4`. left=1 (-1), right=5 (2). `s = 1` < `4` → left++ ... no valid pairs.
3. `i=1` (`-1`): `target=1`. left=2 (-1), right=5 (2).

   * `s = (-1) + 2 = 1` == target → record `[-1,-1,2]`.
   * Skip duplicates around left/right (none), move left->3, right->4.
   * Now left=3 (0), right=4 (1): `s = 1` == target → record `[-1,0,1]`.
   * Move pointers until left >= right.
4. `i=2` (`-1`) skipped because duplicate of `i=1`.
5. Done → return `[[-1,-1,2],[-1,0,1]]`.

**Complexity recap:** `O(n^2)` time, `O(1)` extra space.

---

## Edge cases, pitfalls, and trade-offs

* **Duplicates:** Must skip duplicate `i` values and skip duplicate `left`/`right` values after finding a valid triplet — otherwise you'll return duplicate triplets.
* **All zeros:** If many zeros, code must still return only one `[0,0,0]`. The duplicate-skip logic handles that.
* **Small input sizes:** If `n < 3`, return `[]` immediately.
* **Integer overflow:** In Python not an issue; in languages like Java/C++ mention using `long` if sums may overflow.
* **Performance with many results:** If the array has many valid triplets (rare), returning them may dominate time/memory — clarify output expectations with interviewer.
* **Stability of sorting:** Sorting changes input order; that's fine for this problem but mention it if the problem asked to preserve order.
* **Space vs time trade-offs:** Hash-based two-sum per `i` also gives `O(n^2)` time but uses extra `O(n)` space; sorting + two pointers uses `O(1)` extra space (besides result) and is usually preferred.

**Alternative optimal methods (short):** The hash-based two-sum per `i` gives similar `O(n^2)` expected time but uses `O(n)` auxiliary space; it also needs careful deduplication. For variants like k-sum, recursion + two-pointer after sorting generalizes well.

---

## Follow-ups & hints (for interview follow-ups)

1. **Follow-up:** "What if we want `k`-sum for general `k` (e.g., 4Sum)?"

   * **Hint:** Reduce `k`-sum to `(k-1)`-sum recursively after sorting; base case `k==2` solved by two pointers.

2. **Follow-up:** "Can you return triplets without sorting while keeping `O(n^2)` time?"

   * **Hint:** Use hash set per `i` to find two-sum pairs in `O(n)` (watch duplicates and extra space).

---

## Practice problems (LeetCode preferred)

1. **Two Sum** — *Easy* — LeetCode #1 — `https://leetcode.com/problems/two-sum/`
2. **3Sum Closest** — *Medium* — LeetCode #16 — `https://leetcode.com/problems/3sum-closest/` (variant that asks closest sum to a target)
3. **4Sum** — *Medium* — LeetCode #18 — `https://leetcode.com/problems/4sum/` (generalization; learn recursion on sorted arrays)

---

## How to speak in the interview (mini coaching)

* **Tone:** calm, structured, and confident. Speak in short statements and narrate your thinking.
* **What to say out loud (examples):**

  * "I'll start by clarifying the output format and duplicates — we must not return duplicate triplets."
  * "A naive triple loop is correct but `O(n^3)`; I think we can do better."
  * "If we sort, we can use two pointers to find the remaining two numbers in `O(n)` for each fixed first element, for `O(n^2)` total."
  * While coding: "I'll write the sorting step, then iterate `i`, and add duplicate checks for `i`, and inside implement the two-pointer loop with duplicate skipping after finding a valid triplet."
* **Narrate trade-offs:** mention sorting cost `O(n log n)` and why it's acceptable; mention the hash variant and why it increases space.
* **Common communication mistakes & fixes:**

  * Mistake: jumping into code without stating approach. Fix: briefly outline algorithm first.
  * Mistake: forgetting to handle duplicates. Fix: explicitly state duplicate-handling plan before coding.
  * Mistake: not analyzing complexity. Fix: state time & space complexity at the end.

---

## Quick checklist (what to say and implement)

* Say: "Sort the array, iterate `i` as the first element, use two-pointers to find pairs summing to `-nums[i]`, skip duplicates."
* Implement:

  * `nums.sort()`
  * for `i` in range `0..n-3`: skip if `i>0 and nums[i]==nums[i-1]`
  * two-pointer loop with duplicate skipping after a successful match
* Verify with edge cases: empty, `n<3`, all zeros, duplicates.
* State complexity: `O(n^2)` time, `O(1)` extra space.

---

### Supplement — only when needed

If interviewer asks about returning unique triplets irrespective of order or wants all permutations, clarify expected normalization (usually sorted triplet and deduplicated).
