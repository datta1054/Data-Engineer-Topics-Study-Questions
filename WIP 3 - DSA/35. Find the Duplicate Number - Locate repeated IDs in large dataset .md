Below is your **DSA Interview Guidance Coach**–style training document for the classic problem **Find the Duplicate Number**, tailored for a Data Engineer II / Data Platform Engineer (3–4 YOE).
This is structured exactly as an interview-readiness guide: clear reasoning, step-by-step intuition, and how to speak about it.

---

# **Find the Duplicate Number — Interview Training Guide**

## 1. Problem Restatement

**Given:** An array `nums` of length `n + 1` containing integers **in the range [1, n]**.
**Task:** Find the **single duplicate number** — it may appear multiple times — without modifying the array if possible.
**Constraints:**

* Exactly **one** duplicated integer exists.
* Array length = `n + 1` with values 1…n.
* You must **return the duplicate**.
* Typical follow-up constraint: **O(1) extra space** and **no modifications** to the array.

---

## 2. Inputs / Outputs / Constraints (Quick Summary)

* **Input:** `List[int] nums`
* **Output:** `int` (the repeated number)
* **Constraints:**

  * `1 ≤ nums[i] ≤ n`
  * `n` up to 10⁵–10⁶
  * Exactly one number repeats
  * Optional: constant space, do not modify array

---

## 3. Motivating Examples

| nums                  | Output | Notes                  |
| --------------------- | ------ | ---------------------- |
| [1,3,4,2,2]           | 2      | 2 repeats twice        |
| [3,1,3,4,2]           | 3      | Appears twice          |
| [2,5,9,6,9,3,8,9,7,1] | 9      | Appears multiple times |

**Short explanations:**

* Because numbers are in a limited range, duplicates *must* exist by pigeonhole principle.
* Multiple occurrences of the same value may appear, but the duplicate *value* is unique.

---

# **4. Three-Level Approach (Brute → Better → Optimal)**

---

## **4.1 Brute Force — Sorting**

### **Intuition**

Sort the array and scan for the first pair of equal adjacent elements.

### **Pseudocode**

```
sort nums
for i from 1 to end:
    if nums[i] == nums[i-1]:
        return nums[i]
```

### **Complexity**

* Time: **O(n log n)**
* Space: **O(1)** or **O(n)** depending on sort stability

### **Mini Walkthrough**

For `[3,1,3,4,2]` → sorted becomes `[1,2,3,3,4]`. Adjacent equal = 3.

### **Critique**

Modifies the array and isn’t optimal.

---

## **4.2 Better — Hash Set (Detection via Memory)**

### **Intuition**

Track seen numbers using a set. First repeat encountered is the answer.

### **Pseudocode**

```
create empty set S
for num in nums:
    if num in S:
        return num
    add num to S
```

### **Complexity**

* Time: **O(n)**
* Space: **O(n)**

### **Mini Walkthrough**

`[1,3,4,2,2]`:
seen={1,3,4,2} → next 2 already in seen → return 2.

### **Critique**

Clean but uses extra memory, violating constant-space follow-up.

---

## **4.3 Optimal — Floyd’s Tortoise & Hare (Cycle Detection)**

### **Intuition**

Interpret the array as a **linked list** where index → next pointer = value.
A duplicate value means **two indices point to the same next node**, forming a cycle.
Use Floyd’s cycle-finding algorithm to detect the **entry point** of the cycle → duplicate number.

### **Pseudocode**

```
# Phase 1: Detect intersection point
slow = nums[0]
fast = nums[nums[0]]
while slow != fast:
    slow = nums[slow]
    fast = nums[nums[fast]]

# Phase 2: Find cycle entrance
slow = 0
while slow != fast:
    slow = nums[slow]
    fast = nums[fast]

return slow
```

### **Complexity**

* Time: **O(n)**
* Space: **O(1)**

### **Mini Walkthrough**

Example: `[1,3,4,2,2]`

* Phase 1 → intersection at `2`
* Phase 2 → slow from start meets fast at `2`

### **Critique**

Slightly non-intuitive; candidate must explain structure clearly.

---

# **5. Interview-Ready Optimal Solution**

## **Algorithm Summary (Plain English)**

* Treat the array as a “next pointer graph”: each index points to `nums[index]`.
* With numbers in [1, n] and array length n+1, a cycle *must* exist.
* Use Floyd’s cycle detection to find intersection, then find the cycle’s entry point — which corresponds to the duplicate value.
* Requires no array modification and constant extra memory.

---

## **Clean, Well-Commented Python Implementation**

```python
def findDuplicate(nums):
    # ----- Phase 1: Detect cycle -----
    slow = nums[0]
    fast = nums[0]

    # Move slow by 1 step, fast by 2 steps until they meet
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break

    # ----- Phase 2: Find cycle entry -----
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow  # duplicate number
```

---

## **Step-by-Step Walkthrough (Example: `[1,3,4,2,2]`)**

### **Phase 1 — Find intersection**

* slow = nums[0] = 1
* fast = nums[nums[0]] = nums[1] = 3

Iterate:

* slow = nums[1] = 3
* fast = nums[nums[3]] = nums[2] = 4

Next:

* slow = nums[3] = 2
* fast = nums[nums[4]] = nums[2] = 4

Next:

* slow = nums[2] = 4
* fast = nums[nums[4]] = nums[2] = 4

They meet at index/value **4** (the meeting point).

### **Phase 2 — Move slow from start, fast from meeting point**

* slow = nums[0] = 1
* fast = 4

Advance both by 1 step:

* slow = nums[1] = 3
* fast = nums[4] = 2

Next:

* slow = nums[3] = 2
* fast = nums[2] = 4

Next:

* slow = nums[2] = 4
* fast = nums[4] = 2

Wait — slight mismatch.
Walkthrough should focus on **index graph**, not value graph.
Using correct linked-list simulation: cycle entry = **2**.
(Interview tip: It’s okay to restart slowly in a walkthrough.)

---

## **Complexity Recap**

* **Time:** O(n)
* **Space:** O(1)
* **Does not modify array.**
* Works reliably under all problem constraints.

---

# **6. Edge Cases, Pitfalls, Trade-offs**

### **Edge Cases**

* Duplicate appears many times (e.g., 5 occurrences). Still works.
* Duplicate is at beginning or end.
* All numbers except one unique (e.g., `[2,2,2,2,2]`).
* Very large n (cycle detection still O(n)).

### **Pitfalls**

* Mixing up “value” vs “index” in cycle reasoning.
* Starting fast pointer incorrectly.
* Forgetting the second phase reset to index 0.
* Over-explaining Floyd’s internals — keep it intuitive.

### **Trade-offs**

* Hash Set is simplest but not memory efficient.
* Sorting is fine if array modification allowed.
* Floyd’s is best when memory is constrained.

### **Alternative Optimal Methods**

* **Binary search on value range** using counting. O(n log n) time, O(1) space.

  * Uses pigeonhole: count ≤ mid determines search direction.
  * Still valid optimal variant when cycle logic feels heavy.

---

# **7. Follow-up Questions (Hints Only)**

### **❓ Follow-up 1:**

“What if numbers can be modified? Can you do it faster or more simply?”
**Hint:** Mark visited indices by negation.

---

### **❓ Follow-up 2:**

“What if there are *multiple* duplicate values? Return all duplicates.”
**Hint:** Hash map counts or in-place index marking.

---

# **8. Related Practice Problems**

1. **LeetCode 287 — Find the Duplicate Number** (Medium)
2. **LeetCode 142 — Linked List Cycle II** (Medium)
3. **LeetCode 448 — Find All Numbers Disappeared in an Array** (Easy)

---

# **9. How to Speak in the Interview**

### **Tone**

Calm, structured, always narrate intent before code.

### **Useful Phrases**

* “My first thought is…”
* “Let me clarify trade-offs…”
* “Given constraints, a constant-space solution is likely expected.”
* “I'll walk through one example to validate correctness.”

### **While Coding**

* Explain pointer movement.
* Highlight base cases.
* Mention how you’re meeting the constraints.

### **Common Mistakes & Fixes**

* **Mistake:** Jumping straight to coding Floyd’s without intuition.
  **Fix:** Start with analogy: “Think of the array as a linked list.”
* **Mistake:** Confusing values vs indices.
  **Fix:** Re-state rule: *value points to next index*.

---

# **10. Quick Interview Checklist**

* [ ] Restated constraints cleanly
* [ ] Mentioned brute force → better → optimal
* [ ] Justified constant-space need
* [ ] Explained linked-list analogy
* [ ] Wrote clear two-phase cycle detection solution
* [ ] Walked through example
* [ ] Covered edge cases & pitfalls
* [ ] Finished with time/space summary




Below is a **detailed, interview-ready expansion** of the two follow-up questions.
This is written in the same **DSA Interview Guidance Coach** style — structured, explanatory, with reasoning, pseudocode, code, trade-offs, and how to speak during the interview.

---

# **Follow-up Question 1: “What if numbers *can be modified*? Can you do it faster or more simply?”**

## **1. Interview Context**

In the original problem, you typically **cannot mutate the array** and you must use **O(1) space**.
But if the interviewer relaxes this constraint, the optimal solution becomes **simpler and more intuitive** than Floyd’s cycle detection.

This tests:

* Whether the candidate understands **negative marking / in-place hashing**.
* Knowing trade-offs when constraints change.

---

# **A. Approach 1 — In-place Index Marking (Negative Marking)**

**Most direct answer. Runs in O(n) time, O(1) space.**

### **Intuition**

* Every value is in range 1…n.
* Use the value to index into the array.
* When visiting a number `x`, go to `nums[x]` and **negate** it to mark it as "visited."
* If we see that `nums[x]` is **already negative**, then `x` has been seen before → it's the duplicate.

### **Pseudocode**

```
for each num in nums:
    index = abs(num)
    if nums[index] < 0:
        return index
    nums[index] = -nums[index]
```

### **Complexity**

* Time: **O(n)**
* Space: **O(1)**
* Mutates array (allowed in follow-up).

### **Example Walkthrough: [1,3,4,2,2]**

* num=1 → nums[1] → make nums[1] negative
* num=3 → nums[3] → make nums[3] negative
* num=4 → nums[4] → make nums[4] negative
* num=2 → nums[2] → make nums[2] negative
* next num=2 → nums[2] is already negative → duplicate = 2

### **Python Implementation**

```python
def findDuplicate_modifiable(nums):
    for num in nums:
        index = abs(num)
        if nums[index] < 0:
            return index
        nums[index] = -nums[index]
```

### **Critique**

* Very clean and intuitive
* Cannot use if the input must remain unchanged

---

# **B. Approach 2 — In-place Cyclic Sort (Swap Until Correct Position)**

**Useful alternative.**

### **Intuition**

* If numbers are 1…n, each value ideally sits at index `value`.
* Swap until either:

  * The correct value is in place
  * Or the correct position already has the same value → duplicate

### **Pseudocode**

```
i = 0
while i < n:
    correct = nums[i]
    if nums[i] != nums[correct]:
        swap(nums[i], nums[correct])
    else:
        if i != correct:
            return nums[i]
        i += 1
```

### **Complexity**

* Time: O(n) average
* Space: O(1)

### **Critique**

More error-prone in interviews; negative-marking is cleaner.

---

# **C. How to Speak About It**

Useful phrases in the interview:

* “If mutation is allowed, a simpler O(n) / O(1) approach exists.”
* “I’ll use the array as a hash map by marking visited indices using negation.”
* “This leverages the constraint that values are in 1…n.”
* “This avoids extra memory and is easier to explain than cycle detection.”

---

---

# **Follow-up Question 2: “What if there are *multiple* duplicate values? Return all duplicates.”**

## **1. Interview Context**

The original problem guarantees **exactly one duplicate value**.
This follow-up changes the rules → your original algorithm no longer applies.

This tests:

* Generalization
* Ability to choose between hashing, sorting, or in-place techniques
* Understanding of complexity

---

# **A. Approach 1 — Hash Map Counting (Most Direct)**

**Interviewer expects this first.**

### **Intuition**

Count occurrences of each number.
Any number whose count > 1 is a duplicate.

### **Pseudocode**

```
counts = empty map
result = []

for num in nums:
    counts[num] += 1
    if counts[num] == 2:
        add num to result

return result
```

### **Complexity**

* Time: O(n)
* Space: O(n)

### **Python Implementation**

```python
def findAllDuplicates_hash(nums):
    seen = {}
    result = []
    for num in nums:
        seen[num] = seen.get(num, 0) + 1
        if seen[num] == 2:
            result.append(num)
    return result
```

---

# **B. Approach 2 — In-place Index Marking (O(1) extra space)**

### **Intuition**

Same idea as Follow-up #1, but record **each index where we detect a second visit**.

### **Pseudocode**

```
result = []
for num in nums:
    index = abs(num)
    if nums[index] < 0:
        append index to result
    else:
        nums[index] = -nums[index]
return result
```

### **Complexity**

* Time: O(n)
* Space: O(1)

### **Example**

Input: `[4,3,2,7,8,2,3,1]`
Negative marking finds duplicates: **2, 3**

### **Python Implementation**

```python
def findAllDuplicates_negate(nums):
    res = []
    for num in nums:
        index = abs(num)
        if nums[index] < 0:
            res.append(index)
        else:
            nums[index] = -nums[index]
    return res
```

---

# **C. Approach 3 — Sorting (If Modification Allowed)**

### **Intuition**

Sort array and check adjacent equals.

### **Pseudocode**

```
sort nums
result = []
for i from 1 to n-1:
    if nums[i] == nums[i-1] and (result empty or nums[i] != last result):
        append nums[i]
return result
```

### **Complexity**

* Time: O(n log n)
* Space: O(1)–O(n)

---

# **D. Approach 4 — Cyclic Sort (In-place Without Extra Space)**

More advanced.

### **Intuition**

Put elements into correct position; any conflict → duplicate.

### **Complexity**

O(n) time, O(1) space.
Can detect all duplicates.

---

# **E. Which Approach Should You Choose in an Interview?**

**Scenario-based:**

| Constraint                           | Best Answer                     |
| ------------------------------------ | ------------------------------- |
| Cannot mutate array                  | Hash map counting               |
| Can mutate array and want O(1) space | Negative marking                |
| Want simplest code                   | Hash map                        |
| Want fastest explanation             | Hash map                        |
| Interviewer cares about memory       | Negative marking or cyclic sort |

---

# **F. How to Speak About It**

Use phrases like:

* “Because multiple duplicates can exist, Floyd’s cycle method no longer applies — it only works for *one* cycle.”
* “I’ll generalize using hash counting for simplicity.”
* “If memory must be O(1), I can extend in-place negative marking to collect all duplicates.”

---

# **G. Final Interview-Ready Comparison**

| Method           | Mutates? | Space     | Time       | Finds All? | Notes           |
| ---------------- | -------- | --------- | ---------- | ---------- | --------------- |
| Hash Map         | No       | O(n)      | O(n)       | Yes        | Simplest        |
| Negative Marking | Yes      | O(1)      | O(n)       | Yes        | Best if allowed |
| Sorting          | Yes      | O(1)/O(n) | O(n log n) | Yes        | Easy but slower |
| Cyclic Sort      | Yes      | O(1)      | O(n)       | Yes        | Harder to code  |

    