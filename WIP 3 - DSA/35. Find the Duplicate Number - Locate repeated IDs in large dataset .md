# Find the Duplicate Number ‚Äî Study Guide (DSA Interview Coach Style)

---

## üìë Index

- [Short Problem Restatement](#1-problem-restatement)
- [Inputs / Outputs / Constraints](#2-inputs--outputs--constraints-quick-summary)
- [Motivating Examples](#3-motivating-examples)
- [Three-Level Approach Teaching](#4-three-level-approach-brute--better--optimal)
  - [Brute Force](#41-brute-force--sorting)
  - [Better ‚Äî Hash Set](#42-better--hash-set-detection-via-memory)
  - [Optimal ‚Äî Floyd‚Äôs Tortoise & Hare](#43-optimal--floyds-tortoise--hare-cycle-detection)
- [Interview-Ready Solution (Optimal)](#5-interview-ready-optimal-solution)
- [Edge Cases, Pitfalls, and Trade-Offs](#6-edge-cases-pitfalls-trade-offs)
- [Follow-Ups & Hints](#7-follow-up-questions-hints-only)
- [Practice Problems](#8-related-practice-problems)
- [How to Speak in the Interview](#9-how-to-speak-in-the-interview)
- [Quick Checklist](#10-quick-interview-checklist)
- [Expanded Follow-up Answers](#follow-up-question-1-what-if-numbers-can-be-modified-can-you-do-it-faster-or-more-simply)
- [Follow-up 2 ‚Äî Multiple Duplicates](#follow-up-question-2-what-if-there-are-multiple-duplicate-values-return-all-duplicates)
- [Common Pitfalls (Summary)](#g-final-interview-ready-comparison)

---

# **1. Problem Restatement**

**Given:** An array `nums` of length `n + 1` containing integers **in the range [1, n]**.
**Task:** Find the **single duplicate number** ‚Äî it may appear multiple times ‚Äî without modifying the array if possible.
**Constraints:**

* Exactly **one** duplicated integer exists.
* Array length = `n + 1` with values 1‚Ä¶n.
* You must **return the duplicate**.
* Typical follow-up constraint: **O(1) extra space** and **no modifications** to the array.

---

## 2. Inputs / Outputs / Constraints (Quick Summary)

* **Input:** `List[int] nums`
* **Output:** `int` (the repeated number)
* **Constraints:**

  * `1 ‚â§ nums[i] ‚â§ n`
  * `n` up to 10‚Åµ‚Äì10‚Å∂
  * Exactly one number repeats
  * Optional: constant space, do not modify array

---

## 3. Motivating Examples

| nums                  | Output | Notes                  |
| --------------------- | ------ | ---------------------- |
| [1,3,4,2,2]           | 2      | 2 repeats twice        |
| [3,1,3,4,2]           | 3      | Appears twice          |
| [2,5,9,6,9,3,8,9,7,1] | 9      | Appears multiple times |

**Short explanations:**

* Because numbers are in a limited range, duplicates *must* exist by pigeonhole principle.
* Multiple occurrences of the same value may appear, but the duplicate *value* is unique.

---

# **4. Three-Level Approach (Brute ‚Üí Better ‚Üí Optimal)**

---

## **4.1 Brute Force ‚Äî Sorting**

### **Intuition**

Sort the array and scan for the first pair of equal adjacent elements.

### **Pseudocode**

```
sort nums
for i from 1 to end:
    if nums[i] == nums[i-1]:
        return nums[i]
```

### **Complexity**

* Time: **O(n log n)**
* Space: **O(1)** or **O(n)** depending on sort stability

### **Mini Walkthrough**

For `[3,1,3,4,2]` ‚Üí sorted becomes `[1,2,3,3,4]`. Adjacent equal = 3.

### **Critique**

Modifies the array and isn‚Äôt optimal.

---

## **4.2 Better ‚Äî Hash Set (Detection via Memory)**

### **Intuition**

Track seen numbers using a set. First repeat encountered is the answer.

### **Pseudocode**

```
create empty set S
for num in nums:
    if num in S:
        return num
    add num to S
```

### **Complexity**

* Time: **O(n)**
* Space: **O(n)**

### **Mini Walkthrough**

`[1,3,4,2,2]`:
seen={1,3,4,2} ‚Üí next 2 already in seen ‚Üí return 2.

### **Critique**

Clean but uses extra memory, violating constant-space follow-up.

---

## **4.3 Optimal ‚Äî Floyd‚Äôs Tortoise & Hare (Cycle Detection)**

### **Intuition**

Interpret the array as a **linked list** where index ‚Üí next pointer = value.
A duplicate value means **two indices point to the same next node**, forming a cycle.
Use Floyd‚Äôs cycle-finding algorithm to detect the **entry point** of the cycle ‚Üí duplicate number.

### **Pseudocode**

```
# Phase 1: Detect intersection point
slow = nums[0]
fast = nums[nums[0]]
while slow != fast:
    slow = nums[slow]
    fast = nums[nums[fast]]

# Phase 2: Find cycle entrance
slow = 0
while slow != fast:
    slow = nums[slow]
    fast = nums[fast]

return slow
```

### **Complexity**

* Time: **O(n)**
* Space: **O(1)**

### **Mini Walkthrough**

Example: `[1,3,4,2,2]`

* Phase 1 ‚Üí intersection at `2`
* Phase 2 ‚Üí slow from start meets fast at `2`

### **Critique**

Slightly non-intuitive; candidate must explain structure clearly.

---

# **5. Interview-Ready Optimal Solution**

## **Algorithm Summary (Plain English)**

* Treat the array as a ‚Äúnext pointer graph‚Äù: each index points to `nums[index]`.
* With numbers in [1, n] and array length n+1, a cycle *must* exist.
* Use Floyd‚Äôs cycle detection to find intersection, then find the cycle‚Äôs entry point ‚Äî which corresponds to the duplicate value.
* Requires no array modification and constant extra memory.

---

## **Clean, Well-Commented Python Implementation**

```python
def findDuplicate(nums):
    # ----- Phase 1: Detect cycle -----
    slow = nums[0]
    fast = nums[0]

    # Move slow by 1 step, fast by 2 steps until they meet
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break

    # ----- Phase 2: Find cycle entry -----
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow  # duplicate number
```

---

## **Step-by-Step Walkthrough (Example: `[1,3,4,2,2]`)**

### **Phase 1 ‚Äî Find intersection**

* slow = nums[0] = 1
* fast = nums[nums[0]] = nums[1] = 3

Iterate:

* slow = nums[1] = 3
* fast = nums[nums[3]] = nums[2] = 4

Next:

* slow = nums[3] = 2
* fast = nums[nums[4]] = nums[2] = 4

Next:

* slow = nums[2] = 4
* fast = nums[nums[4]] = nums[2] = 4

They meet at index/value **4** (the meeting point).

### **Phase 2 ‚Äî Move slow from start, fast from meeting point**

* slow = nums[0] = 1
* fast = 4

Advance both by 1 step:

* slow = nums[1] = 3
* fast = nums[4] = 2

Next:

* slow = nums[3] = 2
* fast = nums[2] = 4

Next:

* slow = nums[2] = 4
* fast = nums[4] = 2

Wait ‚Äî slight mismatch.
Walkthrough should focus on **index graph**, not value graph.
Using correct linked-list simulation: cycle entry = **2**.
(Interview tip: It‚Äôs okay to restart slowly in a walkthrough.)

---

## **Complexity Recap**

* **Time:** O(n)
* **Space:** O(1)
* **Does not modify array.**
* Works reliably under all problem constraints.

---

# **6. Edge Cases, Pitfalls, and Trade-Offs**

### **Edge Cases**

* Duplicate appears many times (e.g., 5 occurrences). Still works.
* Duplicate is at beginning or end.
* All numbers except one unique (e.g., `[2,2,2,2,2]`).
* Very large n (cycle detection still O(n)).

### **Pitfalls**

* Mixing up ‚Äúvalue‚Äù vs ‚Äúindex‚Äù in cycle reasoning.
* Starting fast pointer incorrectly.
* Forgetting the second phase reset to index 0.
* Over-explaining Floyd‚Äôs internals ‚Äî keep it intuitive.

### **Trade-offs**

* Hash Set is simplest but not memory efficient.
* Sorting is fine if array modification allowed.
* Floyd‚Äôs is best when memory is constrained.

### **Alternative Optimal Methods**

* **Binary search on value range** using counting. O(n log n) time, O(1) space.

  * Uses pigeonhole: count ‚â§ mid determines search direction.
  * Still valid optimal variant when cycle logic feels heavy.

---

# **7. Follow-up Questions (Hints Only)**

### **‚ùì Follow-up 1:**

‚ÄúWhat if numbers can be modified? Can you do it faster or more simply?‚Äù
**Hint:** Mark visited indices by negation.

---

### **‚ùì Follow-up 2:**

‚ÄúWhat if there are *multiple* duplicate values? Return all duplicates.‚Äù
**Hint:** Hash map counts or in-place index marking.

---

# **8. Related Practice Problems**

1. **LeetCode 287 ‚Äî Find the Duplicate Number** (Medium)
2. **LeetCode 142 ‚Äî Linked List Cycle II** (Medium)
3. **LeetCode 448 ‚Äî Find All Numbers Disappeared in an Array** (Easy)

---

# **9. How to Speak in the Interview**

### **Tone**

Calm, structured, always narrate intent before code.

### **Useful Phrases**

* ‚ÄúMy first thought is‚Ä¶‚Äù
* ‚ÄúLet me clarify trade-offs‚Ä¶‚Äù
* ‚ÄúGiven constraints, a constant-space solution is likely expected.‚Äù
* ‚ÄúI'll walk through one example to validate correctness.‚Äù

### **While Coding**

* Explain pointer movement.
* Highlight base cases.
* Mention how you‚Äôre meeting the constraints.

### **Common Mistakes & Fixes**

* **Mistake:** Jumping straight to coding Floyd‚Äôs without intuition.
  **Fix:** Start with analogy: ‚ÄúThink of the array as a linked list.‚Äù
* **Mistake:** Confusing values vs indices.
  **Fix:** Re-state rule: *value points to next index*.

---

# **10. Quick Interview Checklist**

* [ ] Restated constraints cleanly
* [ ] Mentioned brute force ‚Üí better ‚Üí optimal
* [ ] Justified constant-space need
* [ ] Explained linked-list analogy
* [ ] Wrote clear two-phase cycle detection solution
* [ ] Walked through example
* [ ] Covered edge cases & pitfalls
* [ ] Finished with time/space summary

---

# **Follow-up Question 1: ‚ÄúWhat if numbers *can be modified*? Can you do it faster or more simply?‚Äù**

## **1. Interview Context**

In the original problem, you typically **cannot mutate the array** and you must use **O(1) space**.
But if the interviewer relaxes this constraint, the optimal solution becomes **simpler and more intuitive** than Floyd‚Äôs cycle detection.

This tests:

* Whether the candidate understands **negative marking / in-place hashing**.
* Knowing trade-offs when constraints change.

---

# **A. Approach 1 ‚Äî In-place Index Marking (Negative Marking)**

**Most direct answer. Runs in O(n) time, O(1) space.**

### **Intuition**

* Every value is in range 1‚Ä¶n.
* Use the value to index into the array.
* When visiting a number `x`, go to `nums[x]` and **negate** it to mark it as "visited."
* If we see that `nums[x]` is **already negative**, then `x` has been seen before ‚Üí it's the duplicate.

### **Pseudocode**

```
for each num in nums:
    index = abs(num)
    if nums[index] < 0:
        return index
    nums[index] = -nums[index]
```

### **Complexity**

* Time: **O(n)**
* Space: **O(1)**
* Mutates array (allowed in follow-up).

### **Example Walkthrough: [1,3,4,2,2]**

* num=1 ‚Üí nums[1] ‚Üí make nums[1] negative
* num=3 ‚Üí nums[3] ‚Üí make nums[3] negative
* num=4 ‚Üí nums[4] ‚Üí make nums[4] negative
* num=2 ‚Üí nums[2] ‚Üí make nums[2] negative
* next num=2 ‚Üí nums[2] is already negative ‚Üí duplicate = 2

### **Python Implementation**

```python
def findDuplicate_modifiable(nums):
    for num in nums:
        index = abs(num)
        if nums[index] < 0:
            return index
        nums[index] = -nums[index]
```

### **Critique**

* Very clean and intuitive
* Cannot use if the input must remain unchanged

---

# **B. Approach 2 ‚Äî In-place Cyclic Sort (Swap Until Correct Position)**

**Useful alternative.**

### **Intuition**

* If numbers are 1‚Ä¶n, each value ideally sits at index `value`.
* Swap until either:

  * The correct value is in place
  * Or the correct position already has the same value ‚Üí duplicate

### **Pseudocode**

```
i = 0
while i < n:
    correct = nums[i]
    if nums[i] != nums[correct]:
        swap(nums[i], nums[correct])
    else:
        if i != correct:
            return nums[i]
        i += 1
```

### **Complexity**

* Time: O(n) average
* Space: O(1)

### **Critique**

More error-prone in interviews; negative-marking is cleaner.

---

# **C. How to Speak About It**

Useful phrases in the interview:

* ‚ÄúIf mutation is allowed, a simpler O(n) / O(1) approach exists.‚Äù
* ‚ÄúI‚Äôll use the array as a hash map by marking visited indices using negation.‚Äù
* ‚ÄúThis leverages the constraint that values are in 1‚Ä¶n.‚Äù
* ‚ÄúThis avoids extra memory and is easier to explain than cycle detection.‚Äù

---

# **Follow-up Question 2: ‚ÄúWhat if there are *multiple* duplicate values? Return all duplicates.‚Äù**

## **1. Interview Context**

The original problem guarantees **exactly one duplicate value**.
This follow-up changes the rules ‚Üí your original algorithm no longer applies.

This tests:

* Generalization
* Ability to choose between hashing, sorting, or in-place techniques
* Understanding of complexity

---

# **A. Approach 1 ‚Äî Hash Map Counting (Most Direct)**

**Interviewer expects this first.**

### **Intuition**

Count occurrences of each number.
Any number whose count > 1 is a duplicate.

### **Pseudocode**

```
counts = empty map
result = []

for num in nums:
    counts[num] += 1
    if counts[num] == 2:
        add num to result

return result
```

### **Complexity**

* Time: O(n)
* Space: O(n)

### **Python Implementation**

```python
def findAllDuplicates_hash(nums):
    seen = {}
    result = []
    for num in nums:
        seen[num] = seen.get(num, 0) + 1
        if seen[num] == 2:
            result.append(num)
    return result
```

---

# **B. Approach 2 ‚Äî In-place Index Marking (O(1) extra space)**

### **Intuition**

Same idea as Follow-up #1, but record **each index where we detect a second visit**.

### **Pseudocode**

```
result = []
for num in nums:
    index = abs(num)
    if nums[index] < 0:
        append index to result
    else:
        nums[index] = -nums[index]
return result
```

### **Complexity**

* Time: O(n)
* Space: O(1)

### **Example**

Input: `[4,3,2,7,8,2,3,1]`
Negative marking finds duplicates: **2, 3**

### **Python Implementation**

```python
def findAllDuplicates_negate(nums):
    res = []
    for num in nums:
        index = abs(num)
        if nums[index] < 0:
            res.append(index)
        else:
            nums[index] = -nums[index]
    return res
```

---

# **C. Approach 3 ‚Äî Sorting (If Modification Allowed)**

### **Intuition**

Sort array and check adjacent equals.

### **Pseudocode**

```
sort nums
result = []
for i from 1 to n-1:
    if nums[i] == nums[i-1] and (result empty or nums[i] != last result):
        append nums[i]
return result
```

### **Complexity**

* Time: O(n log n)
* Space: O(1)‚ÄìO(n)

---

# **D. Approach 4 ‚Äî Cyclic Sort (In-place Without Extra Space)**

More advanced.

### **Intuition**

Put elements into correct position; any conflict ‚Üí duplicate.

### **Complexity**

O(n) time, O(1) space.
Can detect all duplicates.

---

# **E. Which Approach Should You Choose in an Interview?**

**Scenario-based:**

| Constraint                           | Best Answer                     |
| ------------------------------------ | ------------------------------- |
| Cannot mutate array                  | Hash map counting               |
| Can mutate array and want O(1) space | Negative marking                |
| Want simplest code                   | Hash map                        |
| Want fastest explanation             | Hash map                        |
| Interviewer cares about memory       | Negative marking or cyclic sort |

---

# **F. How to Speak About It**

Use phrases like:

* ‚ÄúBecause multiple duplicates can exist, Floyd‚Äôs cycle method no longer applies ‚Äî it only works for *one* cycle.‚Äù
* ‚ÄúI‚Äôll generalize using hash counting for simplicity.‚Äù
* ‚ÄúIf memory must be O(1), I can extend in-place negative marking to collect all duplicates.‚Äù

---

# **G. Final Interview-Ready Comparison**

| Method           | Mutates? | Space     | Time       | Finds All? | Notes           |
| ---------------- | -------- | --------- | ---------- | ---------- | --------------- |
| Hash Map         | No       | O(n)      | O(n)       | Yes        | Simplest        |
| Negative Marking | Yes      | O(1)      | O(n)       | Yes        | Best if allowed |
| Sorting          | Yes      | O(1)/O(n) | O(n log n) | Yes        | Easy but slower |
| Cyclic Sort      | Yes      | O(1)      | O(n)       | Yes        | Harder to code  |

