# Longest Substring Without Repeating Characters — Interview Guide

---

## 1) Short problem restatement

**Given:** a string `s`.
**Task:** find the length of the longest substring of `s` that contains no repeating characters.
**Constraints (typical):** `0 <= len(s) <= 10^5` (so aim for O(n) solutions), characters usually ASCII/Unicode.

---

## 2) Inputs / Outputs / Constraints (compact)

* **Input:** `s: str`
* **Output:** `int` — length of the longest substring without repeating characters.
* **Assumptions / limits:** strings can be large (so O(n) time, O(min(n, alphabet)) space preferred). Handle empty string (0).

---

## 3) Motivating examples

| Input        | Output | Short explanation                                                   |
| ------------ | -----: | ------------------------------------------------------------------- |
| `"abcabcbb"` |    `3` | `"abc"` is one longest without repeats.                             |
| `"bbbbb"`    |    `1` | Only single unique char substrings like `"b"`.                      |
| `"pwwkew"`   |    `3` | `"wke"` is length 3; note `"pwk"` isn't contiguous after repeating. |
| `""`         |    `0` | Empty string → length 0.                                            |

Mini note: pay attention to *substring* meaning **contiguous**.

---

## 4) Three-level approach teaching (Brute → Better → Optimal)

### A. Brute force

**Intuition:** test every possible substring and check if it has unique chars.

**Pseudocode**

```
max_len = 0
for i from 0 to n-1:
  for j from i to n-1:
    if substring s[i..j] has all unique chars:
      max_len = max(max_len, j - i + 1)
return max_len
```

**Complexity**

* Time: O(n^3) naive (n^2 substrings × O(n) check). With hashing to check uniqueness, O(n^2) substrings × O(min(n, alphabet)) ≈ O(n^2).
* Space: O(min(n, alphabet)) for the set during check.

**Mini-walkthrough** (s = `"abc"`):

* Check `"a"`, `"ab"`, `"abc"`, then `"b"`, `"bc"`, `"c"`. Finds length 3.

**One-line critique:** Works for tiny input; too slow for typical interview constraints (n up to 10^5).

---

### B. Better (sliding window with set — two pointers)

**Intuition:** maintain a window `[left, right)` with unique chars; expand `right` while possible; when duplicate found, advance `left` until duplicate removed.

**Pseudocode**

```
left = 0
right = 0
seen = empty set
max_len = 0
while right < n:
  if s[right] not in seen:
    add s[right] to seen
    right += 1
    max_len = max(max_len, right - left)
  else:
    remove s[left] from seen
    left += 1
return max_len
```

**Complexity**

* Time: O(n) — each char enters/leaves set at most once.
* Space: O(min(n, alphabet)).

**Mini-walkthrough** (s = `"pwwkew"`):

* right 0 `'p'` add → window `"p"`, max 1.
* right 1 `'w'` add → `"pw"`, max 2.
* right 2 `'w'` duplicate → remove left `'p'`, left=1, still duplicate, remove left `'w'`, left=2, then add `'w'` etc. Window slides and yields max 3 (`"wke"`).

**One-line critique:** Cleaner and O(n) but removing one-by-one from left can be slightly wasteful when we could jump left more directly using indices.

---

### C. Optimal (sliding window with index map — jump left)

**Intuition:** keep a map from character → its most recent index; when encountering a duplicate char at index `i`, jump `left` to `max(left, last_index_of_char + 1)`. This avoids per-step removals.

**Pseudocode**

```
left = 0
max_len = 0
last_index = empty map  # char -> last index seen
for right from 0 to n-1:
  if s[right] in last_index:
    left = max(left, last_index[s[right]] + 1)
  last_index[s[right]] = right
  max_len = max(max_len, right - left + 1)
return max_len
```

**Complexity**

* Time: O(n)
* Space: O(min(n, alphabet))

**Mini-walkthrough** (s = `"abba"`)

* right=0 `'a'`: left=0, last['a']=0, max=1
* right=1 `'b'`: left=0, last['b']=1, max=2 (`"ab"`)
* right=2 `'b'`: last['b']=1 so left = max(0,1+1)=2; last['b']=2; window length = 2-2+1=1
* right=3 `'a'`: last['a']=0 so left = max(2,0+1)=2; last['a']=3; window length = 3-2+1=2
  Result max=2 (either `"ab"` or `"ba"` as valid non-repeating substrings).

**One-line critique:** Best practical method — O(n) and simple to explain.

---

## 5) Interview-ready solution (Optimal)

### Algorithm summary (plain English)

Scan the string once using two pointers `left` and `right` (`right` is the loop index). Keep a dictionary mapping each character to its last seen index. If the character at `right` was previously seen inside the current window, move `left` just after that previous index (but never move `left` backward). Update the map and the best length each iteration.

### Well-commented Python implementation

```python
def length_of_longest_substring(s: str) -> int:
    """
    Return the length of the longest substring without repeating characters.
    Uses sliding window with last-seen index map for O(n) time.
    """
    last_index = {}   # maps character -> last index where it appeared
    left = 0          # left boundary of current window (inclusive)
    max_len = 0

    for right, ch in enumerate(s):
        # If ch was seen and is inside the current window, move left
        if ch in last_index and last_index[ch] >= left:
            # Jump left to one past the previous occurrence
            left = last_index[ch] + 1

        # Update last seen index for ch to the current position
        last_index[ch] = right

        # Update max length: window is [left, right] inclusive
        current_len = right - left + 1
        if current_len > max_len:
            max_len = current_len

    return max_len
```

### Full step-by-step walkthrough on example `"pwwkew"`

* start: `left=0`, `last_index={}`, `max_len=0`
* `right=0`, `ch='p'`: not seen → last['p']=0, current_len=1 → max_len=1
* `right=1`, `ch='w'`: not seen → last['w']=1, current_len=2 → max_len=2
* `right=2`, `ch='w'`: seen at 1 >= left(0) → left = 1+1 = 2; update last['w']=2; current_len = 2-2+1=1 → max_len stays 2
* `right=3`, `ch='k'`: not seen → last['k']=3; current_len = 3-2+1=2 → max_len stays 2
* `right=4`, `ch='e'`: not seen → last['e']=4; current_len = 4-2+1=3 → max_len = 3
* `right=5`, `ch='w'`: seen at 2 >= left(2) → left = 2+1 = 3; update last['w']=5; current_len = 5-3+1=3 → max_len stays 3
* result = `3` (substring `"wke"` or `"kew"` depending on window).

### Complexity recap

* Time: **O(n)** (single pass).
* Space: **O(min(n, alphabet))** for the last_index map.

---

## 6) Edge cases, pitfalls, and trade-offs

**Gotchas & how to avoid:**

* Forgetting to `max(left, last_index[ch] + 1)` — must not move `left` backward when an earlier occurrence is outside current window.
* Off-by-one errors: deciding whether window is `[left, right]` inclusive; code uses inclusive window so length = `right - left + 1`.
* Unicode vs ASCII: if string contains many distinct Unicode points, space can approach O(n).
* Using `.remove()`-style set sliding (the two-pointer set method) is fine but slightly more verbose to explain than index-jump method.
* Not updating map after you move `left` — always update last seen index to current `right`.

**Alternative optimal methods (short):**

* Use array of size 256 (or larger) instead of dict for known small alphabets — faster constant factors.
* For streaming input where you can't index (rare), maintain similar sliding-window state but with more careful memory handling.

---

## 7) Follow-ups & hints (interview-style)

**Follow-up 1:** Return the actual longest substring, not just length.
*Hint:* Keep track of `(best_left, best_right)` when you update `max_len`, then slice `s[best_left:best_right+1]` at the end.

**Follow-up 2:** What if you must find longest substring with *at most k* distinct characters?
*Hint:* Replace `last_index` with a frequency map and maintain count of distinct chars; move `left` until distinct count ≤ k.

---

## 8) Practice problems (3 related; LeetCode preferred)

1. **Longest Substring Without Repeating Characters** — *LeetCode #3 (Medium)*
   [https://leetcode.com/problems/longest-substring-without-repeating-characters/](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
2. **Longest Substring with At Most Two Distinct Characters** — *LeetCode #159 (Medium)*
   [https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/)
3. **Longest Palindromic Substring** — *LeetCode #5 (Medium)* (different technique but substring-focused)
   [https://leetcode.com/problems/longest-palindromic-substring/](https://leetcode.com/problems/longest-palindromic-substring/)

---

## 9) How to speak in the interview

**Tone & style:** confident, organized, concise. Narrate clearly. Use "we" language with the interviewer ("Let's try..." / "We can do...").

**Useful phrases while thinking / coding:**

* "I'll restate the problem briefly: given `s`, return the length of the longest contiguous substring with unique characters."
* "Before coding I'd like to outline a few approaches from naive to optimal."
* "The brute force checks all substrings — that's O(n^2) or O(n^3) depending on checks — too slow for large n."
* "A sliding window with a last-seen map gives us an O(n) solution; I'll implement that and explain the invariants as I go."
* While coding: narrate loop invariants: "At each iteration, `left` and `right` define a window with all unique chars; `last_index` maps chars to their most recent position."
* When done: "Complexity is O(n) time and O(min(n, alphabet)) space. Edge cases: empty string, all-unique, all-same."

**Common communication mistakes & fixes**

* Mistake: jumping into code without stating approach. Fix: quickly outline approach and complexities first.
* Mistake: not explaining how `left` update avoids moving backward. Fix: explicitly state `left = max(left, last_index[ch] + 1)`.
* Mistake: forgetting edge cases. Fix: mention empty string and single-character strings before coding.

---

## 10) Quick checklist (what to say / do in interview)

* Restate problem and edge cases in 1 sentence.
* Sketch brute → better → optimal approaches and their complexities.
* Choose sliding-window + last-index map; state invariant (`window has unique chars`).
* Implement clean code and narrate key lines (especially the left-jump).
* Run 2 quick tests aloud (`"abcabcbb"`, `""`).
* Summarize complexity and alternative trade-offs.

---

### Supplement — short cheat-sheet (only when needed)

* Window length formula: `right - left + 1`.
* Update left only with `max(left, last_index[ch] + 1)` to avoid regressions.
* Use array[256] instead of dict when working only with ASCII for slightly faster performance.