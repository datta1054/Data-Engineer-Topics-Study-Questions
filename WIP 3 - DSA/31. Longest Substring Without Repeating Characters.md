
# Longest Substring Without Repeating Characters — Study Guide

---

## Problem Restatement

Given a string `s`, find the length of the longest substring of `s` that contains no repeating characters.
Constraints: `0 <= len(s) <= 10^5` (aim for O(n) solutions), characters usually ASCII/Unicode.

---

## Inputs / Outputs / Constraints

Input: `s: str`
Output: `int` — length of the longest substring without repeating characters.
Assumptions: strings can be large (O(n) time, O(min(n, alphabet)) space preferred). Handle empty string (0).

---

## Motivating Examples

| Input        | Output | Explanation                                                   |
| ------------ | -----: | ------------------------------------------------------------- |
| `"abcabcbb"` |    `3` | `"abc"` is one longest without repeats.                       |
| `"bbbbb"`    |    `1` | Only single unique char substrings like `"b"`.                |
| `"pwwkew"`   |    `3` | `"wke"` is length 3; note `"pwk"` isn't contiguous after repeat.|
| `""`         |    `0` | Empty string → length 0.                                      |

*Note: substring means contiguous.*

---

## Approaches: Brute → Better → Optimal

### Brute Force

Intuition: Test every possible substring and check if it has unique chars.

Pseudocode:
```
max_len = 0
for i from 0 to n-1:
  for j from i to n-1:
    if substring s[i..j] has all unique chars:
      max_len = max(max_len, j - i + 1)
return max_len
```
Complexity: Time O(n^3) naive (n^2 substrings × O(n) check), O(n^2) with hashing. Space O(min(n, alphabet)).

Mini-walkthrough (s = `"abc"`): Check `"a"`, `"ab"`, `"abc"`, then `"b"`, `"bc"`, `"c"`. Finds length 3.

Critique: Too slow for large n.

---

### Better (Sliding Window with Set)

Intuition: Maintain a window `[left, right)` with unique chars; expand `right` while possible; when duplicate found, advance `left` until duplicate removed.

Pseudocode:
```
left = 0
right = 0
seen = empty set
max_len = 0
while right < n:
  if s[right] not in seen:
    add s[right] to seen
    right += 1
    max_len = max(max_len, right - left)
  else:
    remove s[left] from seen
    left += 1
return max_len
```
Complexity: Time O(n), Space O(min(n, alphabet)).

Mini-walkthrough (s = `"pwwkew"`): right 0 `'p'` add → window `"p"`, max 1. right 1 `'w'` add → `"pw"`, max 2. right 2 `'w'` duplicate → remove left `'p'`, left=1, still duplicate, remove left `'w'`, left=2, then add `'w'` etc. Window slides and yields max 3 (`"wke"`).

Critique: O(n), but removing one-by-one from left can be wasteful.

---

### Optimal (Sliding Window with Index Map)

Intuition: Keep a map from character → its most recent index; when encountering a duplicate char at index `i`, jump `left` to `max(left, last_index_of_char + 1)`.

Pseudocode:
```
left = 0
max_len = 0
last_index = empty map  # char -> last index seen
for right from 0 to n-1:
  if s[right] in last_index:
    left = max(left, last_index[s[right]] + 1)
  last_index[s[right]] = right
  max_len = max(max_len, right - left + 1)
return max_len
```
Complexity: Time O(n), Space O(min(n, alphabet)).

Mini-walkthrough (s = `"abba"`): right=0 `'a'`: left=0, last['a']=0, max=1. right=1 `'b'`: left=0, last['b']=1, max=2 (`"ab"`). right=2 `'b'`: last['b']=1 so left = max(0,1+1)=2; last['b']=2; window length = 2-2+1=1. right=3 `'a'`: last['a']=0 so left = max(2,0+1)=2; last['a']=3; window length = 3-2+1=2. Result max=2 (either `"ab"` or `"ba"`).

Critique: Best practical method — O(n) and simple to explain.

---

## Interview-Ready Solution (Optimal)

Algorithm summary: Scan the string once using two pointers `left` and `right`. Keep a dictionary mapping each character to its last seen index. If the character at `right` was previously seen inside the current window, move `left` just after that previous index. Update the map and the best length each iteration.

Python implementation:
```python
def length_of_longest_substring(s: str) -> int:
    """
    Return the length of the longest substring without repeating characters.
    Uses sliding window with last-seen index map for O(n) time.
    """
    last_index = {}   # maps character -> last index where it appeared
    left = 0          # left boundary of current window (inclusive)
    max_len = 0

    for right, ch in enumerate(s):
        # If ch was seen and is inside the current window, move left
        if ch in last_index and last_index[ch] >= left:
            # Jump left to one past the previous occurrence
            left = last_index[ch] + 1

        # Update last seen index for ch to the current position
        last_index[ch] = right

        # Update max length: window is [left, right] inclusive
        current_len = right - left + 1
        if current_len > max_len:
            max_len = current_len

    return max_len
```

---

## Step-by-Step Walkthrough

Example: `"pwwkew"`

* start: `left=0`, `last_index={}`, `max_len=0`
* `right=0`, `ch='p'`: not seen → last['p']=0, current_len=1 → max_len=1
* `right=1`, `ch='w'`: not seen → last['w']=1, current_len=2 → max_len=2
* `right=2`, `ch='w'`: seen at 1 >= left(0) → left = 1+1 = 2; update last['w']=2; current_len = 2-2+1=1 → max_len stays 2
* `right=3`, `ch='k'`: not seen → last['k']=3; current_len = 3-2+1=2 → max_len stays 2
* `right=4`, `ch='e'`: not seen → last['e']=4; current_len = 4-2+1=3 → max_len = 3
* `right=5`, `ch='w'`: seen at 2 >= left(2) → left = 2+1 = 3; update last['w']=5; current_len = 5-3+1=3 → max_len stays 3
* result = `3` (substring `"wke"` or `"kew"`)

---

## Complexity Recap

Time: O(n) (single pass). Space: O(min(n, alphabet)) for the last_index map.

---

## Edge Cases, Pitfalls, and Trade-offs

* Don't move `left` backward: always use `max(left, last_index[ch] + 1)`
* Off-by-one errors: window is `[left, right]` inclusive, so length = `right - left + 1`
* Unicode vs ASCII: many distinct Unicode points can use more space
* Not updating map after moving `left`: always update last seen index

Alternative optimal methods:
* Use array of size 256 (or larger) for known small alphabets
* For streaming input, maintain similar sliding-window state with careful memory handling

---

## Follow-ups & Hints

1. Return the actual longest substring, not just length.  
   *Hint:* Keep track of `(best_left, best_right)` when you update `max_len`, then slice `s[best_left:best_right+1]` at the end.
2. What if you must find longest substring with *at most k* distinct characters?  
   *Hint:* Replace `last_index` with a frequency map and maintain count of distinct chars; move `left` until distinct count ≤ k.

---

## Practice Problems

1. Longest Substring Without Repeating Characters — LeetCode #3 (Medium)  
   https://leetcode.com/problems/longest-substring-without-repeating-characters/
2. Longest Substring with At Most Two Distinct Characters — LeetCode #159 (Medium)  
   https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/
3. Longest Palindromic Substring — LeetCode #5 (Medium)  
   https://leetcode.com/problems/longest-palindromic-substring/

---

## Interview Communication Guide

Tone: confident, organized, concise. Narrate clearly. Use "we" language with the interviewer ("Let's try..." / "We can do...").

Useful phrases:
* "I'll restate the problem briefly: given `s`, return the length of the longest contiguous substring with unique characters."
* "Before coding I'd like to outline a few approaches from naive to optimal."
* "The brute force checks all substrings — that's O(n^2) or O(n^3) depending on checks — too slow for large n."
* "A sliding window with a last-seen map gives us an O(n) solution; I'll implement that and explain the invariants as I go."
* While coding: narrate loop invariants: "At each iteration, `left` and `right` define a window with all unique chars; `last_index` maps chars to their most recent position."
* When done: "Complexity is O(n) time and O(min(n, alphabet)) space. Edge cases: empty string, all-unique, all-same."

Common communication mistakes & fixes:
* Jumping into code without stating approach. Fix: quickly outline approach and complexities first.
* Not explaining how `left` update avoids moving backward. Fix: explicitly state `left = max(left, last_index[ch] + 1)`.
* Forgetting edge cases. Fix: mention empty string and single-character strings before coding.

---

## Quick Checklist

* Restate problem and edge cases in 1 sentence
* Sketch brute → better → optimal approaches and their complexities
* Choose sliding-window + last-index map; state invariant (`window has unique chars`)
* Implement clean code and narrate key lines (especially the left-jump)
* Run 2 quick tests aloud (`"abcabcbb"`, `""`)
* Summarize complexity and alternative trade-offs

---

## Supplement (Cheat Sheet)

* Window length formula: `right - left + 1`
* Update left only with `max(left, last_index[ch] + 1)` to avoid regressions
* Use array[256] instead of dict when working only with ASCII for slightly faster performance