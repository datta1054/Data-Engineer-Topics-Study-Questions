# Subarray Sum Equals K — Interview Study Guide

Goal: Learn to **understand**, **reason about**, **implement**, and **communicate** the solution to *Subarray Sum Equals K* in an interview.

---

## Problem restatement (short)

**Given:** an integer array `nums` and an integer `k`.
**Task:** Return the **number of continuous subarrays** whose sum equals `k`.
**Constraints:** array may contain **negative** and positive integers; answer fits in a 32/64-bit integer depending on language.

---

## Inputs / Outputs / Constraints (quick)

* **Input:** `nums: List[int]`, `k: int`
* **Output:** `int` — count of subarrays `nums[i..j]` such that sum equals `k`.
* **Important limits (typical):**

  * `1 <= len(nums) <= ~2e4` (may vary by problem source)
  * `nums[i]` can be negative, zero, or positive
  * Time & space matter — aim for O(n) time, O(n) space if possible

---

## Motivating examples

| nums              |  k | output | short explanation                    |
| ----------------- | -: | -----: | ------------------------------------ |
| [1, 1, 1]         |  2 |      2 | subarrays [1,1] at (0..1) and (1..2) |
| [1, 2, 3]         |  3 |      2 | [1,2] and [3]                        |
| [1, -1, 1, -1, 1] |  1 |      5 | many overlapping subarrays sum to 1  |

Example explanation (short): In `[1,1,1]`, contiguous windows of length 2 at positions (0..1) and (1..2) both sum to 2 → count = 2.

---

## Three-level approach teaching (Brute → Better → Optimal)

### Level 1 — Brute force (naïve)

**Intuition:** Try every possible subarray and sum it from scratch. Very direct, easy to reason but expensive.

**Pseudocode**

```
count = 0
for start in 0..n-1:
    for end in start..n-1:
        s = 0
        for i in start..end:
            s += nums[i]
        if s == k: count += 1
return count
```

**Complexity**

* Time: O(n³) (n² subarrays × O(n) sum)
* Space: O(1)

**Mini walkthrough** on `nums=[1,1,1], k=2`

* start=0,end=0 => sum=1 !=2
* start=0,end=1 => sum=1+1=2 => count=1
* start=0,end=2 => sum=3
* start=1,end=1 => sum=1
* start=1,end=2 => sum=2 => count=2
* start=2,end=2 => sum=1
  Return 2.

**One-line critique:** Simple but too slow for moderate n; unnecessary repeated sums.

---

### Level 2 — Better (prefix / cumulative sum + nested loops)

**Intuition:** Precompute prefix sums so each subarray sum can be computed in O(1). Then still iterate all start/end pairs.

**Pseudocode**

```
prefix[0] = 0
for i in 0..n-1:
    prefix[i+1] = prefix[i] + nums[i]

count = 0
for start in 0..n-1:
    for end in start..n-1:
        sub_sum = prefix[end+1] - prefix[start]
        if sub_sum == k: count += 1
return count
```

**Complexity**

* Time: O(n²) (n² subarray pairs, constant time per pair)
* Space: O(n) for prefix array

**Mini walkthrough** on `nums=[1,1,1], k=2`

* prefix = [0,1,2,3]
* start=0,end=1 => sub_sum = prefix[2]-prefix[0] = 2 → count=1
* start=1,end=2 => sub_sum = prefix[3]-prefix[1] = 2 → count=2
  Return 2.

**One-line critique:** Much better than brute; still quadratic and can time out for ~20k elements.

---

### Level 3 — Optimal (prefix-sum hash map / frequency map)

**Intuition (core idea):** Let `prefix[i]` be cumulative sum up to index `i-1`. For current prefix sum `cur`, we want number of earlier prefixes `prev` such that `cur - prev == k` → `prev == cur - k`. Maintain a hashmap counting occurrences of each prefix sum seen so far. For each index, add `freq[cur - k]` to the answer, then record `cur` in the map.

This counts all subarrays ending at current index whose sum is `k`. Works with negatives.

**Short pseudocode**

```
count = 0
cur = 0
freq = {0:1}   // one way to have prefix sum 0 before starting
for each num in nums:
    cur += num
    if (cur - k) in freq:
        count += freq[cur - k]
    freq[cur] = freq.get(cur, 0) + 1
return count
```

**Complexity**

* Time: O(n) — single pass
* Space: O(n) — hashmap of prefix sum frequencies (worst-case distinct prefixes)

**Mini walkthrough** on `nums=[1,1,1], k=2`

* start: cur=0, freq={0:1}, count=0
* read 1 → cur=1, cur-k = -1 → freq[-1] missing → count=0; freq={0:1,1:1}
* read 1 → cur=2, cur-k = 0 → freq[0]=1 → count=1; freq={0:1,1:1,2:1}
* read 1 → cur=3, cur-k = 1 → freq[1]=1 → count=2; freq={0:1,1:1,2:1,3:1}
  Return 2.

**One-line critique:** Optimal and elegant — linear time, handles negatives.

---

## Interview-ready solution (Optimal)

### Algorithm summary (plain English)

Traverse the array while maintaining the cumulative sum `cur`. For each `cur`, the number of earlier prefixes equal to `cur - k` gives how many subarrays ending at the current index sum to `k`. Use a hashmap `freq` that maps prefix sums to their counts. Initialize `freq[0] = 1` to account for subarrays starting at index 0. Update answer and then increment the count of `cur` in the map.

### Well-commented Python implementation

```python
def subarray_sum_equals_k(nums, k):
    """
    Count number of contiguous subarrays summing to k.
    Time: O(n), Space: O(n)
    """
    from collections import defaultdict

    freq = defaultdict(int)
    freq[0] = 1   # base case: one prefix sum 0 before starting
    cur = 0
    count = 0

    for x in nums:
        cur += x
        # If there exists a previous prefix with value (cur - k),
        # then subarray(s) from after that prefix to current index sum to k.
        count += freq.get(cur - k, 0)
        # Record current prefix sum for future subarrays.
        freq[cur] += 1

    return count
```

### Step-by-step walkthrough on example `nums = [1, -1, 1, -1, 1]`, `k = 1`

* init: `freq={0:1}`, `cur=0`, `count=0`
* read 1 → `cur=1`; `cur-k=0` → `freq[0]=1` → `count=1`; then `freq[1]=1`
* read -1 → `cur=0`; `cur-k=-1` → `freq[-1]=0` → `count=1`; `freq[0]=2`
* read 1 → `cur=1`; `cur-k=0` → `freq[0]=2` → `count=3` (two subarrays ending here); `freq[1]=2`
* read -1 → `cur=0`; `cur-k=-1` → `freq[-1]=0` → `count=3`; `freq[0]=3`
* read 1 → `cur=1`; `cur-k=0` → `freq[0]=3` → `count=6`; `freq[1]=3`
  Return `count=6`. (This is correct for that input — shows how overlapping counts accumulate.)

### Complexity recap

* Time: O(n) — one pass, constant-time hash ops
* Space: O(n) — worst-case distinct cumulative sums

---

## Edge cases, pitfalls, and trade-offs

**Practical gotchas**

* Forgetting to initialize `freq[0] = 1` — you'll miss subarrays starting at index 0.
* Using the prefix map incorrectly (e.g., updating freq before querying) — order matters: query `freq[cur - k]` first, then increment `freq[cur]`.
* Integer overflow is rarely a concern in Python, but in languages like C++/Java watch cumulative sum types.
* If `nums` is extremely large and memory is tight, the O(n) map could be a bottleneck — consider constraints.
* Sliding window techniques **do not** work if the array contains negatives; only valid for all-positive arrays.

**How to avoid them**

* Always initialize freq[0]=1.
* In code, keep the order: compute `cur`, add `freq[cur - k]` to count, then increment `freq[cur]`.
* Use 64-bit integers for languages with typed integers.

**Alternative optimal methods (short)**

* If `nums` are **all non-negative**, a **two-pointer / sliding window** approach can find subarrays with sum `k` in O(n). But sliding window fails when negatives are allowed.
* Another variation: use prefix-sum array + binary search when prefix sums are monotonic (only with non-negative numbers).

---

## Follow-ups & hints (interview-style; give hints only)

1. **Follow-up:** Return the actual subarray indices (start, end) of all subarrays summing to `k` (not just the count).
   **Hint:** Instead of storing only counts for a prefix sum in the map, store the list of indices where that prefix sum occurred; then when you encounter `cur - k`, every stored index gives a valid start.

2. **Follow-up:** Suppose you need the longest subarray whose sum equals `k`.
   **Hint:** Track earliest occurrence index for each prefix sum (store first index only) — longest window is `current_index - earliest_index_for(cur - k)`.

---

## Practice problems

1. **Subarray Sum Equals K** — LeetCode #560 (same problem).
   [https://leetcode.com/problems/subarray-sum-equals-k/](https://leetcode.com/problems/subarray-sum-equals-k/)  — *Easy/Medium*
2. **Continuous Subarray Sum** — LeetCode #523 (check for subarray of length >= 2 with sum multiple of k).
   [https://leetcode.com/problems/continuous-subarray-sum/](https://leetcode.com/problems/continuous-subarray-sum/)  — *Medium*
3. **Subarray Sum Closest / Two Sum variants** — e.g., LeetCode *Two Sum* (hashmap pattern) and *Maximum Size Subarray Sum Equals k* (#325).
   [https://leetcode.com/problems/two-sum/](https://leetcode.com/problems/two-sum/)  — *Easy*
   [https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/)  — *Medium*

---

## How to speak in the interview (mini coaching)

* **Tone:** calm, methodical, and confident. Start high-level, then drill down.
* **What to say first:** "I will restate the problem to confirm: given `nums` and `k`, count contiguous subarrays that sum to `k`. Arrays can include negatives — that rules out sliding-window."
* **Narration while designing:** Describe approaches with trade-offs: "Brute force checks all subarrays — O(n³). We can reduce repeated work via prefix sums to O(n²). To get O(n) we use a prefix-frequency map to count how many earlier prefixes give `cur - k`."
* **While coding:** Narrate each block: "I'll initialize freq[0]=1 to capture subarrays starting at index 0... now for each x update cur and look up cur-k..."
* **Common mistakes & fixes:** If interviewer points out complexity, quickly state: "Yes, the prefix map gives O(n) time and O(n) space; if numbers are non-negative, sliding-window is alternative but not here due to negatives."
* **Example phrases to use:**

  * "I'll start with a simple brute-force to clarify correctness, then optimize."
  * "Important edge case: empty prefix (sum 0) — I handle that by initializing freq[0]=1."
  * "I will maintain cumulative sum and a hashmap from prefix sum to its frequency — that allows constant-time counting per element."
* **Common communication mistakes + fix:**

  * Mistake: Coding without explaining. Fix: Before writing code, summarize the algorithm in 2–3 sentences.
  * Mistake: Not considering negatives and suggesting sliding window. Fix: Call out assumptions explicitly ("sliding window requires non-negative values; here array may have negatives").

---

## Quick checklist (what to say & do in interview)

* Restate problem & constraints (mention negatives).
* Outline 3 approaches briefly (brute, prefix array, prefix-hash).
* Argue for the O(n) prefix-hash solution and its correctness.
* Write code with `freq[0] = 1`, update `cur`, query `freq[cur - k]`, then `freq[cur] += 1`.
* Mention complexity: Time O(n), Space O(n).
* Discuss edge cases (empty array, k=0, negatives) and follow-ups (indices, longest).

---
### Supplement — short note (only when needed)

If interviewer restricts memory, discuss trade-offs: you can stream through array and keep only necessary prefix sums, but you must keep counts for all distinct prefix sums seen — worst-case still O(n).
